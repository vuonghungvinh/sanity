'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

var _Descender = require('./Descender');

var _Descender2 = _interopRequireDefault(_Descender);

var _Expression = require('./Expression');

var _Expression2 = _interopRequireDefault(_Expression);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Matcher = function () {
  function Matcher(active, parent) {
    _classCallCheck(this, Matcher);

    this.active = active || [];
    if (parent) {
      this.recursives = parent.recursives;
      this.payload = parent.payload;
    } else {
      this.recursives = [];
    }
    this.extractRecursives();
  }

  _createClass(Matcher, [{
    key: 'setPayload',
    value: function setPayload(payload) {
      this.payload = payload;
      return this;
    }

    // Moves any recursive descenders onto the recursive track, removing them from
    // the active set

  }, {
    key: 'extractRecursives',
    value: function extractRecursives() {
      var _this = this;

      // console.log(JSON.stringify(this.active))
      this.active = this.active.filter(function (descender) {
        if (descender.isRecursive()) {
          var _recursives;

          (_recursives = _this.recursives).push.apply(_recursives, _toConsumableArray(descender.extractRecursives()));
          return false;
        }
        return true;
      });
    }

    // Find recursives that are relevant now and should be considered part of the active set

  }, {
    key: 'activeRecursives',
    value: function activeRecursives(probe) {
      return this.recursives.filter(function (descender) {
        var head = descender.head;
        // Constraints are always relevant
        if (head.isConstraint()) {
          return true;
        }
        // Index references are only relevant for indexable values
        if (probe.containerType() == 'array' && head.isIndexReference()) {
          return true;
        }
        // Attribute references are relevant for plain objects
        if (probe.containerType() == 'object') {
          if (head.isAttributeReference() && probe.hasAttribute(head.name())) {
            return true;
          }
        }
        return false;
      });
    }
  }, {
    key: 'match',
    value: function match(probe) {
      return this.iterate(probe).extractMatches(probe);
    }
  }, {
    key: 'iterate',
    value: function iterate(probe) {
      var newActiveSet = [];
      this.active.concat(this.activeRecursives(probe)).forEach(function (descender) {
        newActiveSet.push.apply(newActiveSet, _toConsumableArray(descender.iterate(probe)));
      });
      return new Matcher(newActiveSet, this);
    }

    // Returns true if any of the descenders in the active or recursive set
    // consider the current state a final destination

  }, {
    key: 'isDestination',
    value: function isDestination() {
      var arrival = this.active.find(function (descender) {
        if (descender.hasArrived()) {
          return true;
        }
        return false;
      });
      return !!arrival;
    }
  }, {
    key: 'hasRecursives',
    value: function hasRecursives() {
      return this.recursives.length > 0;
    }

    // Returns any payload delivieries and leads that needs to be followed to complete
    // the process.

  }, {
    key: 'extractMatches',
    value: function extractMatches(probe) {
      var _this2 = this;

      var leads = [];
      var targets = [];
      this.active.forEach(function (descender) {
        if (descender.hasArrived()) {
          // This was allready arrived, so matches this value, not descenders
          targets.push(new _Expression2.default({
            type: 'alias',
            target: 'self'
          }));
          return;
        }
        if (probe.containerType() == 'array' && !descender.head.isIndexReference()) {
          // This descender does not match an indexable value
          return;
        }
        if (probe.containerType() == 'object' && !descender.head.isAttributeReference()) {
          // This descender never match a plain object
          return;
        }
        // const newDescenders = descender.descend()
        // console.log('newDescenders', newDescenders)
        if (descender.tail) {
          // Not arrived yet
          var matcher = new Matcher(descender.descend(), _this2);
          descender.head.toFieldReferences().forEach(function (field) {
            leads.push({
              target: descender.head,
              matcher: matcher
            });
          });
        } else {
          // arrived
          targets.push(descender.head);
        }
      });

      // If there are recursive terms, we need to add a lead for every descendant ...
      if (this.hasRecursives()) {
        // The recustives matcher will have no active set, only inherit recursives from this
        var recursivesMatcher = new Matcher([], this);
        if (probe.containerType() == 'array') {
          var length = probe.length();
          for (var i = 0; i < length; i++) {
            leads.push({
              target: _Expression2.default.indexReference(i),
              matcher: recursivesMatcher
            });
          }
        } else if (probe.containerType() == 'object') {
          probe.attributeKeys().forEach(function (name) {
            leads.push({
              target: _Expression2.default.attributeReference(name),
              matcher: recursivesMatcher
            });
          });
        }
      }

      var result = {
        leads: leads
      };
      if (targets.length > 0) {
        result.delivery = {
          targets: targets,
          payload: this.payload
        };
      }
      return result;
    }
  }], [{
    key: 'fromPath',
    value: function fromPath(jsonpath) {
      var descender = new _Descender2.default(null, new _Expression2.default((0, _parse2.default)(jsonpath)));
      return new Matcher(descender.descend());
    }
  }]);

  return Matcher;
}();

exports.default = Matcher;