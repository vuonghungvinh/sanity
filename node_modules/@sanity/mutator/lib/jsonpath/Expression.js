'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// A utility wrapper class to process parsed jsonpath expressions

var _descend2 = require('./descend');

var _descend3 = _interopRequireDefault(_descend2);

var _toPath = require('./toPath');

var _toPath2 = _interopRequireDefault(_toPath);

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Expression = function () {
  function Expression(expr) {
    _classCallCheck(this, Expression);

    // This is a wrapped expr
    if (expr.expr) {
      this.expr = expr.expr;
    } else {
      this.expr = expr;
    }
    if (!this.expr.type) {
      throw new Error('Attempt to create Expression for expression with no type');
    }
  }

  _createClass(Expression, [{
    key: 'isPath',
    value: function isPath() {
      return this.expr.type == 'path';
    }
  }, {
    key: 'isUnion',
    value: function isUnion() {
      return this.expr.type == 'union';
    }
  }, {
    key: 'isCollection',
    value: function isCollection() {
      return this.isPath() || this.isUnion();
    }
  }, {
    key: 'isConstraint',
    value: function isConstraint() {
      return this.expr.type == 'constraint';
    }
  }, {
    key: 'isRecursive',
    value: function isRecursive() {
      return this.expr.type == 'recursive';
    }
  }, {
    key: 'isExistenceConstraint',
    value: function isExistenceConstraint() {
      return this.isConstraint() && this.expr.operator == '?';
    }
  }, {
    key: 'isIndex',
    value: function isIndex() {
      return this.expr.type == 'index';
    }
  }, {
    key: 'isRange',
    value: function isRange() {
      return this.expr.type == 'range';
    }
  }, {
    key: 'expandRange',
    value: function expandRange(probe) {
      var start = this.expr.start || 0;
      start = interpretNegativeIndex(start, probe);
      var end = this.expr.end || probe.length();
      end = interpretNegativeIndex(end, probe);
      var step = this.expr.step || 1;
      return { start: start, end: end, step: step };
    }
  }, {
    key: 'isAttributeReference',
    value: function isAttributeReference() {
      return this.expr.type == 'attribute';
    }
    // Is a range or index -> something referencing indexes

  }, {
    key: 'isIndexReference',
    value: function isIndexReference() {
      return this.isIndex() || this.isRange();
    }
  }, {
    key: 'name',
    value: function name() {
      return this.expr.name;
    }
  }, {
    key: 'isSelfReference',
    value: function isSelfReference() {
      return this.expr.type == 'alias' && this.expr.target == 'self';
    }
  }, {
    key: 'constraintTargetIsSelf',
    value: function constraintTargetIsSelf() {
      return this.isConstraint() && this.expr.lhs.type == 'alias' && this.expr.lhs.target == 'self';
    }
  }, {
    key: 'constraintTargetIsAttribute',
    value: function constraintTargetIsAttribute() {
      return this.isConstraint() && this.expr.lhs.type == 'attribute';
    }
  }, {
    key: 'testConstraint',
    value: function testConstraint(probe) {
      if (this.constraintTargetIsSelf()) {
        if (probe.containerType() != 'primitive') {
          return false;
        }
        if (this.isExistenceConstraint()) {
          return true;
        }
        var _lhs = probe.get();
        var _rhs = this.expr.rhs.value;
        return testBinaryOperator(_lhs, this.expr.operator, _rhs);
      }
      if (!this.constraintTargetIsAttribute()) {
        throw new Error('Constraint target ' + this.expr.lhs.type + ' not supported');
      }
      if (probe.containerType() != 'object') {
        return false;
      }
      var lhs = probe.getAttribute(this.expr.lhs.name);
      if (lhs === undefined || lhs === null || lhs.containerType() != 'primitive') {
        // LHS is void and empty, or it is a collection
        return false;
      }
      if (this.isExistenceConstraint()) {
        // There is no rhs, and if we're here the key did exist
        return true;
      }
      var rhs = this.expr.rhs.value;
      return testBinaryOperator(lhs.get(), this.expr.operator, rhs);
    }
  }, {
    key: 'pathNodes',
    value: function pathNodes() {
      if (this.isPath()) {
        return this.expr.nodes;
      }
      return [this.expr];
    }
  }, {
    key: 'prepend',
    value: function prepend(node) {
      if (!node) {
        return this;
      }
      return new Expression({
        type: 'path',
        nodes: node.pathNodes().concat(this.pathNodes())
      });
    }
  }, {
    key: 'concat',
    value: function concat(other) {
      if (!other) {
        return this;
      }
      return other.prepend(this);
    }
  }, {
    key: 'descend',
    value: function descend() {
      return (0, _descend3.default)(this.expr).map(function (headTail) {
        var _headTail = _slicedToArray(headTail, 2),
            head = _headTail[0],
            tail = _headTail[1];

        return {
          head: head ? new Expression(head) : null,
          tail: tail ? new Expression(tail) : null
        };
      });
    }
  }, {
    key: 'unwrapRecursive',
    value: function unwrapRecursive() {
      if (!this.isRecursive()) {
        throw new Error('Attempt to unwrap recursive on type ' + this.expr.type);
      }
      return new Expression(this.expr.term);
    }
  }, {
    key: 'toIndicies',
    value: function toIndicies(probe) {
      if (!this.isIndexReference()) {
        throw new Error('Node cannot be converted to indexes');
      }
      if (this.expr.type == 'index') {
        return [interpretNegativeIndex(this.expr.value, probe)];
      } else if (this.expr.type == 'range') {
        var result = [];

        var _expandRange = this.expandRange(probe),
            start = _expandRange.start,
            end = _expandRange.end,
            step = _expandRange.step;

        if (step < 0) {
          var _ref = [end, start];
          start = _ref[0];
          end = _ref[1];
        }
        for (var i = start; i < end; i++) {
          result.push(i);
        }
        return result;
      }
      throw new Error('Unable to convert ' + this.expr.type + ' to indices');
    }
  }, {
    key: 'toFieldReferences',
    value: function toFieldReferences() {
      if (this.isIndexReference()) {
        return this.toIndicies();
      }
      if (this.isAttributeReference()) {
        return [this.name()];
      }
      throw new Error('Can\'t convert ' + this.expr.type + ' to field references');
    }
  }, {
    key: 'toString',
    value: function toString() {
      return (0, _toPath2.default)(this.expr);
    }
  }], [{
    key: 'fromPath',
    value: function fromPath(path) {
      return new Expression((0, _parse2.default)(path));
    }
  }, {
    key: 'attributeReference',
    value: function attributeReference(name) {
      return new Expression({
        type: 'attribute',
        name: name
      });
    }
  }, {
    key: 'indexReference',
    value: function indexReference(i) {
      return new Expression({
        type: 'index',
        value: i
      });
    }
  }]);

  return Expression;
}();

// Tests an operator on two given primitive values


exports.default = Expression;
function testBinaryOperator(lhsValue, operator, rhsValue) {
  switch (operator) {
    case '>':
      return lhsValue > rhsValue;
    case '>=':
      return lhsValue >= rhsValue;
    case '<':
      return lhsValue < rhsValue;
    case '<=':
      return lhsValue <= rhsValue;
    case '==':
      return lhsValue == rhsValue;
    case '!=':
      return lhsValue != rhsValue;
    default:
      throw new Error('Unsupported binary operator ' + operator);
  }
}
function interpretNegativeIndex(index, probe) {
  if (index < 0) {
    return index + probe.length();
  }
  return index;
}