'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toPath;

// Converts a parsed expression back into jsonpath2, roughly - mostly for use
// with tests.

function toPath(expr) {
  return toPathInner(expr, false);
}

function toPathInner(expr, inUnion) {
  switch (expr.type) {
    case 'attribute':
      return expr.name;
    case 'alias':
      return expr.target === 'self' ? '@' : '$';
    case 'number':
      return '' + expr.value;
    case 'range':
      {
        var result = [];
        if (!inUnion) {
          result.push('[');
        }
        if (expr.start) {
          result.push('' + expr.start);
        }
        result.push(':');
        if (expr.end) {
          result.push('' + expr.end);
        }
        if (expr.step) {
          result.push(':' + expr.step);
        }
        if (!inUnion) {
          result.push(']');
        }
        return result.join('');
      }
    case 'index':
      if (inUnion) {
        return '' + expr.value;
      }
      return '[' + expr.value + ']';
    case 'constraint':
      var inner = toPathInner(expr.lhs, false) + ' ' + expr.operator + ' ' + toPathInner(expr.rhs, false);
      if (inUnion) {
        return inner;
      }
      return '[' + inner + ']';
    case 'string':
      return JSON.stringify(expr.value);
    case 'path':
      {
        var _result = [];
        var nodes = expr.nodes.slice();
        while (nodes.length > 0) {
          var node = nodes.shift();
          _result.push(toPath(node, false));
          var upcoming = nodes[0];
          if (upcoming && toPathInner(upcoming, false)[0] !== '[') {
            _result.push('.');
          }
        }
        return _result.join('');
      }
    case 'union':
      var terms = expr.nodes.map(function (e) {
        return toPathInner(e, true);
      });
      return '[' + terms.join(',') + ']';
    default:
      throw new Error('Unknown node type ' + expr.type);
    case 'recursive':
      return '..' + toPathInner(expr.term, false);
  }
}