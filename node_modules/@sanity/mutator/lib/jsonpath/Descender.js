'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// Descender models the state of one partial jsonpath evaluation. Head is the
// next thing to match, tail is the upcoming things once the head is matched.

var _Expression = require('./Expression');

var _Expression2 = _interopRequireDefault(_Expression);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Descender = function () {
  function Descender(head, tail) {
    _classCallCheck(this, Descender);

    this.head = head;
    this.tail = tail;
  }
  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head


  _createClass(Descender, [{
    key: 'iterate',
    value: function iterate(probe) {
      var result = [this];
      if (this.head && this.head.isConstraint()) {
        var anyConstraints = true;
        // Keep rewriting constraints until there are none left
        while (anyConstraints) {
          result = (0, _flatten3.default)(result.map(function (descender) {
            return descender.iterateConstraints(probe);
          }));
          anyConstraints = result.find(function (descender) {
            return descender.head && descender.head.isConstraint();
          });
        }
      }
      return result;
    }
  }, {
    key: 'isRecursive',
    value: function isRecursive() {
      return this.head && this.head.isRecursive();
    }
  }, {
    key: 'hasArrived',
    value: function hasArrived() {
      return this.head === null && this.tail === null;
    }
  }, {
    key: 'extractRecursives',
    value: function extractRecursives() {
      if (this.head.isRecursive()) {
        var term = this.head.unwrapRecursive();
        return new Descender(null, term.concat(this.tail)).descend();
      }
      return [];
    }
  }, {
    key: 'iterateConstraints',
    value: function iterateConstraints(probe) {
      var head = this.head;
      if (head === null || !head.isConstraint()) {
        // Not a constraint, no rewrite
        return [this];
      }

      var result = [];

      if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {
        if (head.testConstraint(probe)) {
          result.push.apply(result, _toConsumableArray(this.descend()));
        }
        return result;
      }

      // The value is an array
      if (probe.containerType() === 'array') {
        var length = probe.length();
        for (var i = 0; i < length; i++) {
          // Push new descenders with constraint translated to literal indices
          // where they match
          if (head.testConstraint(probe.getIndex(i))) {
            result.push(new Descender(new _Expression2.default({ type: 'index', value: i }), this.tail));
          }
        }
        return result;
      }

      // The value is an object
      if (probe.containerType() == 'object') {
        if (this.head.constraintTargetIsSelf()) {
          // There are no matches for target self ('@') on a plain object
          return [];
        }
        if (this.head.testConstraint(probe)) {
          return this.descend();
        }
        return result;
      }

      return result;
    }
  }, {
    key: 'descend',
    value: function descend() {
      if (!this.tail) {
        return [new Descender(null, null)];
      }
      return this.tail.descend().map(function (ht) {
        return new Descender(ht.head, ht.tail);
      });
    }
  }, {
    key: 'toString',
    value: function toString() {
      var result = ['<'];
      if (this.head) {
        result.push(this.head.toString());
      }
      result.push('|');
      if (this.tail) {
        result.push(this.tail.toString());
      }
      result.push('>');
      return result.join('');
    }
  }]);

  return Descender;
}();

exports.default = Descender;