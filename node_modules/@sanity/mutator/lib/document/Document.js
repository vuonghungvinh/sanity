'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

// Models a document as it is changed by our own local patches and remote patches coming in from
// the server. Consolidates incoming patches with our own submitted patches and maintains two
// versions of the document. EDGE is the optimistic document that the user sees that will always
// immediately reflect whatever she is doing to it, and HEAD which is the confirmed version of the
// document consistent with the mutations we have received from the server. As long as nothing out of
// the ordinary happens, we can track all changes by hooking into the onMutation callback, but we
// must also respect onRebase events that fire when we have to backtrack because one of our optimistically
// applied patches were rejected, or some bastard was able to slip a mutation in between ours own.

// TODO: When we have timestamps on mutation notifications, we can reject incoming mutations that are older
// than the document we are seeing.

var _Mutation = require('./Mutation');

var _Mutation2 = _interopRequireDefault(_Mutation);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Document = function () {
  // We are consistent when there are no unresolved mutations of our own, and no un-applicable incoming mutations.
  // When this has been going on for too long, and there has been a while since we staged a new mutation,
  //  it is time to reset your state.

  // Called when we receive a patch in the normal order of things, but the mutation is not ours

  // Our optimistic model of what the document will probably look like as soon as all our patches have been
  // processed. Updated every time we stage a new mutation, but also might revert back to previous states
  // if our mutations fail, or could change if unexpected mutations arrive between our own. The onRebase
  // callback will be called when EDGE changes in this manner.

  // Incoming patches from the server waiting to be applied to HEAD
  function Document(doc) {
    _classCallCheck(this, Document);

    this.reset(doc);
  }

  // Reset the state of the Document, used to recover from unsavory states by reloading the document

  // The last time we staged a patch of our own. If we have been inconsistent for a while, but it hasn't been long since
  // we staged a new mutation, the reason is probably just because the user is typing or something. Should be used as
  // a guard agains resetting state for inconsistensy reasons.

  // Called when consistency state changes with the boolean value of the current consistency state

  // Called with the EDGE document when that document changes for a reason other than us staging a new patch
  // or receiving a mutation from the server while our EDGE is in sync with HEAD: I.e. when EDGE changes because
  // the order of mutations has changed in relation to our optimistic predictions.

  // Our model of the document according to the incoming patches from the server

  // Patches we know has been subitted to the server, but has not been seen yet in the return channel
  // so we can't be sure about the ordering yet (someone else might have slipped something between them)


  _createClass(Document, [{
    key: 'reset',
    value: function reset(doc) {
      this.incoming = [];
      this.submitted = [];
      this.pending = [];
      this.inconsistentAt = null;
      this.HEAD = doc;
      this.EDGE = doc;
      this.considerIncoming();
      this.updateConsistencyFlag();
    }

    // Call when a mutation arrives from Sanity

  }, {
    key: 'arrive',
    value: function arrive(mutation) {
      this.incoming.push(mutation);
      this.considerIncoming();
      this.updateConsistencyFlag();
    }

    // Call to signal that we are submitting a mutation. Returns a callback object with a
    // success and failure handler that must be called according to the outcome of our
    // submission.

  }, {
    key: 'stage',
    value: function stage(mutation, silent) {
      var _this = this;

      if (!mutation.transactionId) {
        throw new Error('Mutations _must_ have transactionId when submitted');
      }
      this.lastStagedAt = new Date();

      (0, _debug2.default)('Staging mutation ' + mutation.transactionId + ' (pushed to pending)');
      this.pending.push(mutation);
      this.EDGE = mutation.apply(this.EDGE);

      if (this.onMutation && !silent) {
        this.onMutation({
          mutation: mutation,
          document: this.EDGE,
          remote: false
        });
      }

      var txnId = mutation.transactionId;

      this.updateConsistencyFlag();

      return {
        success: function success() {
          _this.pendingSuccessfullySubmitted(txnId);
          _this.updateConsistencyFlag();
        },
        failure: function failure() {
          _this.pendingFailed(txnId);
          _this.updateConsistencyFlag();
        }
      };
    }

    // Call to check if everything is nice and quiet and there are no unresolved mutations. Means this model
    // thinks both HEAD and EDGE is up to date with what the server sees.

  }, {
    key: 'isConsistent',
    value: function isConsistent() {
      return !this.inconsistentAt;
    }

    // Private

    // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there are
    // applicable patches to be applied

  }, {
    key: 'considerIncoming',
    value: function considerIncoming() {
      var _this2 = this;

      var mustRebase = false;
      var nextMut = void 0;
      // Filter mutations that are older than the document
      if (this.HEAD) {
        var updatedAt = new Date(this.HEAD._updatedAt);
        if (this.incoming.find(function (mut) {
          return mut.timestamp && mut.timestamp < updatedAt;
        })) {
          this.incoming = this.incoming.filter(function (mut) {
            return mut.timestamp < updatedAt;
          });
        }
      }

      // Keep applying mutations as long as any apply
      var protect = 0;
      do {
        // Find next mutation that can be applied to HEAD (if any)
        if (this.HEAD) {
          nextMut = this.incoming.find(function (mut) {
            return mut.previousRev == _this2.HEAD._rev;
          });
        } else {
          // When HEAD is null, that means the document is currently deleted. Only mutations that start with a create
          // operation will be considered.
          nextMut = this.incoming.find(function (mut) {
            return mut.appliesToMissingDocument();
          });
        }
        mustRebase = mustRebase || this.applyIncoming(nextMut);
        if (protect++ > 100) {
          throw new Error('Mutator stuck flusing incoming mutations. Probably stuck here:', JSON.stringify(nextMut));
        }
      } while (nextMut);

      if (this.incoming.length > 0) {
        (0, _debug2.default)('Unable to apply mutations %s', this.incoming.map(function (mut) {
          return mut.transactionId;
        }).join(', '));
      }

      if (mustRebase) {
        this.rebase();
      }
    }

    // check current consistency state, update flag and invoke callback if needed

  }, {
    key: 'updateConsistencyFlag',
    value: function updateConsistencyFlag() {
      var wasConsistent = this.isConsistent();
      var isConsistent = this.pending.length == 0 && this.submitted.length == 0 && this.incoming.length == 0;
      // Update the consistency state, taking care not to update the timestamp if we were inconsistent and still are
      if (isConsistent) {
        this.inconsistentAt = null;
      } else if (!this.inconsistentAt) {
        this.inconsistentAt = new Date();
      }
      // Handle onConsistencyChanged callback
      if (wasConsistent != isConsistent && this.onConsistencyChanged) {
        if (isConsistent) {
          (0, _debug2.default)('Buffered document is inconsistent');
        } else {
          (0, _debug2.default)('Buffered document is consistent');
        }
        this.onConsistencyChanged(isConsistent);
      }
    }

    // apply an incoming patch that has been prequalified as the next in line for this document

  }, {
    key: 'applyIncoming',
    value: function applyIncoming(mut) {
      if (!mut) {
        return false;
      }
      (0, _debug2.default)('Applying mutation %s -> %s to rev %s', mut.previousRev, mut.resultRev, this.HEAD && this.HEAD._rev);

      this.HEAD = mut.apply(this.HEAD);

      // Eliminate from incoming set
      this.incoming = this.incoming.filter(function (m) {
        return m.transactionId != mut.transactionId;
      });

      if (this.anyUnresolvedMutations()) {
        (0, _debug2.default)('Incoming mutation ' + mut.transactionId + ' appeared while there were pending or submitted local mutations');
        (0, _debug2.default)('Submitted txnIds: ' + this.submitted.map(function (m) {
          return m.transactionId;
        }).join(', '));
        (0, _debug2.default)('Pending txnIds: ' + this.pending.map(function (m) {
          return m.transactionId;
        }).join(', '));
        var needRebase = this.consumeUnresolved(mut.transactionId);
        (0, _debug2.default)('needRebase == ' + needRebase);
        return needRebase;
      }
      (0, _debug2.default)('Remote mutation ' + mut.transactionId + ' arrived w/o any pending or submitted local mutations');
      this.EDGE = this.HEAD;
      if (this.onMutation) {
        this.onMutation({
          mutation: mut,
          document: this.EDGE,
          remote: true
        });
      }
      return false;
    }

    // Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
    // mutations that are still waiting to be either submitted, or to be confirmed by the
    // server.

  }, {
    key: 'anyUnresolvedMutations',
    value: function anyUnresolvedMutations() {
      return this.submitted.length > 0 || this.pending.length > 0;
    }

    // When an incoming mutation is applied to HEAD, this is called to remove the mutation from
    // the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
    // no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
    // that case we are given the flag `needRebase` to tell us that this mutation arrived out of order
    // in terms of our optimistic version, so a rebase is needed.

  }, {
    key: 'consumeUnresolved',
    value: function consumeUnresolved(txnId) {
      // If we have nothing queued up, we are in sync and can apply patch with no
      // rebasing
      if (this.submitted.length == 0 && this.pending.length == 0) {
        return false;
      }
      // If we can consume the directly upcoming mutation, we won't have to rebase
      if (this.submitted.length != 0) {
        if (this.submitted[0].transactionId == txnId) {
          (0, _debug2.default)('Remote mutation ' + txnId + ' matches upcoming submitted mutation, consumed from \'submitted\' buffer');
          this.submitted.shift();
          return false;
        }
      } else if (this.pending.length > 0 && this.pending[0].transactionId == txnId) {
        // There are no submitted, but some are pending so let's check the upcoming pending
        (0, _debug2.default)('Remote mutation ' + txnId + ' matches upcoming pending mutation, consumed from \'pending\' buffer');
        this.pending.shift();
        return false;
      }
      (0, _debug2.default)('The mutation was not the upcoming mutation, scrubbing. Pending: ' + this.pending.length + ', Submitted: ' + this.submitted.length);
      // The mutation was not the upcoming mutation, so we'll have to check everything to
      // see if we have an out of order situation
      this.submitted = this.submitted.filter(function (mut) {
        return mut.transactionId != txnId;
      });
      this.pending = this.pending.filter(function (mut) {
        return mut.transactionId != txnId;
      });
      (0, _debug2.default)('After scrubbing: Pending: ' + this.pending.length + ', Submitted: ' + this.submitted.length);
      // Whether we had it or not we have either a reordering, or an unexpected mutation
      // so must rebase
      return true;
    }
  }, {
    key: 'pendingSuccessfullySubmitted',
    value: function pendingSuccessfullySubmitted(pendingTxnId) {
      if (this.pending.length == 0) {
        // If there are no pending, it has probably arrived allready
        return;
      }
      var first = this.pending[0];
      if (first.transactionId == pendingTxnId) {
        // Nice, the pending transaction arrived in order
        this.submitted.push(this.pending.shift());
        return;
      }
      // Oh, no. Submitted out of order.
      var justSubmitted = void 0;
      var stillPending = [];
      this.pending.forEach(function (mutation) {
        if (mutation.transactionId == pendingTxnId) {
          justSubmitted = mutation;
          return;
        }
        stillPending.push(mutation);
      });
      if (!justSubmitted) {
        // Not found? Hopefully it has allready arrived. Might have been forgotten by now
      }
      this.submitted.push(justSubmitted);
      this.pending = stillPending;
      // Must rebase since mutation order has changed
      this.rebase();
    }
  }, {
    key: 'pendingFailed',
    value: function pendingFailed(pendingTxnId) {
      this.pending = this.pending.filter(function (mutation) {
        return mutation.transactionId != pendingTxnId;
      });
      // Rebase to revert document to what it looked like before the failed mutation
      this.rebase();
    }
  }, {
    key: 'rebase',
    value: function rebase() {
      var oldEdge = this.EDGE;
      this.EDGE = _Mutation2.default.applyAll(this.HEAD, this.submitted.concat(this.pending));
      // Copy over rev, since we don't care if it changed, we only care about the content
      if (oldEdge !== null && this.EDGE !== null) {
        oldEdge._rev = this.EDGE._rev;
      }
      var changed = !(0, _isEqual3.default)(this.EDGE, oldEdge);
      if (changed && this.onRebase) {
        this.onRebase(this.EDGE);
      }
    }
  }]);

  return Document;
}();

exports.default = Document;