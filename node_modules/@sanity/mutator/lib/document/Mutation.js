'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _patch = require('../patch');

var _luid = require('./luid');

var _luid2 = _interopRequireDefault(_luid);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// A mutation describing a number of operations on a single document
// This should be considered an immutable structure. Mutations are compiled
// on first application, and any changes in properties will not effectively
// change its behavior after that.
var Mutation = function () {
  function Mutation(options) {
    _classCallCheck(this, Mutation);

    this.params = options;
  }

  _createClass(Mutation, [{
    key: 'assignRandomTransactionId',
    value: function assignRandomTransactionId() {
      this.params.resultRev = this.params.transactionId = (0, _luid2.default)();
    }
  }, {
    key: 'appliesToMissingDocument',
    value: function appliesToMissingDocument() {
      if (typeof this._appliesToMissingDocument !== 'undefined') {
        return this._appliesToMissingDocument;
      }
      // Only mutations starting with a create operation apply to documents that do not exist ...
      var firstMut = this.mutations[0];
      if (firstMut) {
        this._appliesToMissingDocument = firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace;
      } else {
        this._appliesToMissingDocument = true;
      }
      return this._appliesToMissingDocument;
    }
    // Compiles all mutations into a handy function

  }, {
    key: 'compile',
    value: function compile() {
      var _this = this;

      var operations = [];
      this.mutations.forEach(function (mutation) {
        if (mutation.create) {
          // TODO: Fail entire patch if document did exist
          operations.push(function (doc) {
            return doc === null ? Object.assign(mutation.create, { _createdAt: _this.params.timestamp }) : doc;
          });
        } else if (mutation.createIfNotExists) {
          operations.push(function (doc) {
            return doc === null ? Object.assign(mutation.createIfNotExists, { _createdAt: _this.params.timestamp }) : doc;
          });
        } else if (mutation.createOrReplace) {
          operations.push(function () {
            return Object.assign(mutation.createOrReplace, { _createdAt: _this.params.timestamp });
          });
        } else if (mutation.delete) {
          operations.push(function () {
            return null;
          });
        } else if (mutation.patch) {
          var patch = new _patch.Patcher(mutation.patch);
          operations.push(function (doc) {
            return patch.apply(doc);
          });
        } else {
          throw new Error('Unsupported mutation ' + JSON.stringify(mutation, null, 2));
        }
      });
      if (typeof this.params.timestamp === 'string') {
        operations.push(function (doc) {
          if (doc) {
            return Object.assign(doc, { _updatedAt: _this.params.timestamp });
          }
          return doc;
        });
      }
      var prevRev = this.previousRev;
      var rev = this.resultRev || this.transactionId;
      this.compiled = function (doc) {
        if (prevRev && prevRev != doc._rev) {
          throw new Error('Previous revision for this mutation was ' + prevRev + ', but the document revision is ' + doc._rev);
        }
        var result = operations.reduce(function (revision, operation) {
          return operation(revision);
        }, doc);
        if (result && rev) {
          result._rev = rev;
        }
        return result;
      };
    }
  }, {
    key: 'apply',
    value: function apply(document) {
      (0, _debug2.default)('Applying mutation ' + JSON.stringify(this.mutations) + ' to document ' + JSON.stringify(document));
      if (!this.compiled) {
        this.compile();
      }
      var result = this.compiled(document);
      (0, _debug2.default)('  => ' + JSON.stringify(result));
      return result;
    }
  }, {
    key: 'transactionId',
    get: function get() {
      return this.params.transactionId;
    }
  }, {
    key: 'transition',
    get: function get() {
      return this.params.transition;
    }
  }, {
    key: 'identity',
    get: function get() {
      return this.params.identity;
    }
  }, {
    key: 'previousRev',
    get: function get() {
      return this.params.previousRev;
    }
  }, {
    key: 'resultRev',
    get: function get() {
      return this.params.resultRev;
    }
  }, {
    key: 'mutations',
    get: function get() {
      return this.params.mutations;
    }
  }, {
    key: 'timestamp',
    get: function get() {
      if (typeof this.params.timestamp == 'string') {
        return new Date(this.params.timestamp);
      }
      return undefined;
    }
  }], [{
    key: 'applyAll',
    value: function applyAll(document, mutations) {
      return mutations.reduce(function (doc, mutation) {
        return mutation.apply(doc);
      }, document);
    }
    // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
    // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
    // that all mutations are on the same document.
    // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!

  }, {
    key: 'squash',
    value: function squash(document, mutations) {
      var squashed = mutations.reduce(function (result, mutation) {
        return result.concat.apply(result, _toConsumableArray(mutation.mutations));
      }, []);
      return new Mutation({ mutations: squashed });
    }
  }]);

  return Mutation;
}();

exports.default = Mutation;