'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _getBackingStoreRatio = require('./getBackingStoreRatio');

var _getBackingStoreRatio2 = _interopRequireDefault(_getBackingStoreRatio);

var _makeDragAware = require('./makeDragAware');

var _makeDragAware2 = _interopRequireDefault(_makeDragAware);

var _utils = require('./2d/utils');

var utils2d = _interopRequireWildcard(_utils);

var _shapes = require('./2d/shapes');

var _cursors = require('./cursors');

var cursors = _interopRequireWildcard(_cursors);

var _constants = require('./constants');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DragAwareCanvas = (0, _makeDragAware2.default)('canvas');

// The margin available in all directions for drawing the crop tool
var MARGIN_PX = 8;
var CROP_HANDLE_SIZE = 12;
var HOTSPOT_HANDLE_SIZE = 10;

function getCropCursorForHandle(handle) {
  switch (handle) {
    case 'left':
    case 'right':
      return 'col-resize';

    case 'top':
    case 'bottom':
      return 'row-resize';

    case 'topRight':
    case 'bottomLeft':
      return 'nesw-resize';

    case 'topLeft':
    case 'bottomRight':
      return 'nwse-resize';
    default:
      return null;
  }
}

var ImageTool = function (_React$PureComponent) {
  _inherits(ImageTool, _React$PureComponent);

  function ImageTool() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ImageTool);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ImageTool.__proto__ || Object.getPrototypeOf(ImageTool)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      devicePixelVsBackingStoreRatio: null,
      cropping: false,
      cropMoving: false,
      dragging: false,
      moving: false
    }, _this.handleDragStart = function (_ref2) {
      var x = _ref2.x,
          y = _ref2.y;

      var mousePosition = { x: x * _this.getScale(), y: y * _this.getScale() };

      var inHotspot = utils2d.isPointInEllipse(mousePosition, _this.getHotspotRect());

      var inDragHandle = utils2d.isPointInCircle(mousePosition, _this.getDragHandleCoords());

      var activeCropHandle = _this.getActiveCropHandleFor(mousePosition);

      var inCropRect = utils2d.isPointInRect(mousePosition, _this.getCropRect());

      if (activeCropHandle) {
        _this.setState({ cropping: activeCropHandle });
      } else if (inDragHandle) {
        _this.setState({ resizing: true });
      } else if (inHotspot) {
        _this.setState({ moving: true });
      } else if (inCropRect) {
        _this.setState({ cropMoving: true });
      }
    }, _this.handleDrag = function (pos) {
      if (_this.state.cropping) {
        _this.emitCrop(_this.state.cropping, pos);
      } else if (_this.state.cropMoving) {
        _this.emitCropMove(pos);
      } else if (_this.state.moving) {
        _this.emitMove(pos);
      } else if (_this.state.resizing) {
        _this.emitResize(pos);
      }
    }, _this.handleDragEnd = function (pos) {
      var onChange = _this.props.onChange;

      _this.setState({ moving: false, resizing: false, cropping: false, cropMoving: false });

      var _this$getClampedValue = _this.getClampedValue(),
          hotspot = _this$getClampedValue.hotspot,
          crop = _this$getClampedValue.crop;

      onChange({
        crop: {
          top: crop.top,
          bottom: 1 - crop.bottom,
          left: crop.left,
          right: 1 - crop.right
        },
        hotspot: {
          x: hotspot.center.x,
          y: hotspot.center.y,
          height: Math.abs(hotspot.height),
          width: Math.abs(hotspot.width)
        }
      });
    }, _this.handleMouseOut = function () {
      _this.setState({ mousePosition: null });
    }, _this.handleMouseMove = function (event) {
      var clientRect = event.target.getBoundingClientRect();
      _this.setState({
        mousePosition: {
          x: (event.clientX - clientRect.left) * _this.getScale(),
          y: (event.clientY - clientRect.top) * _this.getScale()
        }
      });
    }, _this.setCanvas = function (node) {
      _this.canvas = node;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ImageTool, [{
    key: 'getHotspotRect',
    value: function getHotspotRect() {
      var _props = this.props,
          value = _props.value,
          image = _props.image;


      var hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
      var hotspotRect = new _shapes.Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);

      return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).multiply(hotspotRect);
    }
  }, {
    key: 'getCropRect',
    value: function getCropRect() {
      var _props2 = this.props,
          value = _props2.value,
          image = _props2.image;


      return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).cropRelative(_shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1)));
    }
  }, {
    key: 'getCropHandles',
    value: function getCropHandles() {

      var inner = this.getCropRect();

      var handleSize = CROP_HANDLE_SIZE * this.getScale();

      var halfCropHandleSize = handleSize / 2;

      var cropHandle = new _shapes.Rect(0, 0, handleSize, handleSize);
      return {
        left: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.center.y - halfCropHandleSize),
        right: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.center.y - halfCropHandleSize),

        top: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.top - halfCropHandleSize),
        topLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.top - halfCropHandleSize),
        topRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.top - halfCropHandleSize),

        bottom: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.bottom - halfCropHandleSize),
        bottomLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.bottom - halfCropHandleSize),
        bottomRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.bottom - halfCropHandleSize)
      };
    }
  }, {
    key: 'getActiveCropHandleFor',
    value: function getActiveCropHandleFor(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      var cropHandles = this.getCropHandles();

      return Object.keys(cropHandles).find(function (position) {
        return utils2d.isPointInRect({ x: x, y: y }, cropHandles[position]);
      });
    }
  }, {
    key: 'applyHotspotMoveBy',
    value: function applyHotspotMoveBy(value, delta) {
      return Object.assign({}, value, {
        hotspot: Object.assign({}, value.hotspot, {
          x: value.hotspot.x + delta.x,
          y: value.hotspot.y + delta.y
        })
      });
    }
  }, {
    key: 'applyHotspotResizeBy',
    value: function applyHotspotResizeBy(value, delta) {
      return Object.assign({}, value, {
        hotspot: Object.assign({}, value.hotspot, {
          height: value.hotspot.height + delta.height,
          width: value.hotspot.width + delta.width
        })
      });
    }
  }, {
    key: 'applyCropMoveBy',
    value: function applyCropMoveBy(value, delta) {
      return Object.assign({}, value, {
        crop: Object.assign({}, value.crop, {
          left: value.crop.left + (delta.left || 0),
          right: value.crop.right + (delta.right || 0),
          top: value.crop.top + (delta.top || 0),
          bottom: value.crop.bottom + (delta.bottom || 0)
        })
      });
    }
  }, {
    key: 'emitMove',
    value: function emitMove(pos) {
      var _props3 = this.props,
          image = _props3.image,
          value = _props3.value,
          onChange = _props3.onChange;

      var scale = this.getScale();
      var delta = {
        x: pos.x * scale / image.width,
        y: pos.y * scale / image.height
      };

      onChange(this.applyHotspotMoveBy(value, delta));
    }
  }, {
    key: 'emitCropMove',
    value: function emitCropMove(pos) {
      var _props4 = this.props,
          image = _props4.image,
          onChange = _props4.onChange,
          value = _props4.value;

      var scale = this.getScale();
      var delta = {};
      delta.left = pos.x * scale / image.width;
      delta.right = -pos.x * scale / image.width;

      delta.top = pos.y * scale / image.height;
      delta.bottom = -pos.y * scale / image.height;

      onChange(this.applyCropMoveBy(value, delta));
    }
  }, {
    key: 'emitCrop',
    value: function emitCrop(side, pos) {
      var _props5 = this.props,
          image = _props5.image,
          onChange = _props5.onChange,
          value = _props5.value;

      var scale = this.getScale();
      var delta = {};

      if (side == 'left' || side === 'topLeft' || side === 'bottomLeft') {
        delta.left = pos.x * scale / image.width;
      } else if (side == 'right' || side === 'topRight' || side === 'bottomRight') {
        delta.right = -pos.x * scale / image.width;
      }

      if (side == 'top' || side === 'topLeft' || side === 'topRight') {
        delta.top = pos.y * scale / image.height;
      } else if (side == 'bottom' || side === 'bottomLeft' || side === 'bottomRight') {
        delta.bottom = -pos.y * scale / image.height;
      }

      onChange(this.applyCropMoveBy(value, delta));
    }
  }, {
    key: 'emitResize',
    value: function emitResize(pos) {
      var _props6 = this.props,
          image = _props6.image,
          onChange = _props6.onChange,
          value = _props6.value;

      var scale = this.getScale();

      var delta = {
        x: pos.x * scale * 2 / image.width,
        y: pos.y * scale * 2 / image.height
      };
      onChange(this.applyHotspotResizeBy(value, { height: delta.y, width: delta.x }));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        devicePixelVsBackingStoreRatio: this.getDevicePixelVsBackingStoreRatio(this.canvas.domNode.getContext('2d'))
      });
    }
  }, {
    key: 'getDevicePixelVsBackingStoreRatio',
    value: function getDevicePixelVsBackingStoreRatio(context) {
      var devicePixelRatio = window.devicePixelRatio || 1;
      var backingStoreRatio = (0, _getBackingStoreRatio2.default)(context) || 1;
      return devicePixelRatio / backingStoreRatio;
    }
  }, {
    key: 'getClampedValue',
    value: function getClampedValue() {
      var value = this.props.value;

      var crop = _shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1));

      var hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
      var hotspotRect = new _shapes.Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);

      return { crop: crop, hotspot: hotspotRect };
    }
  }, {
    key: 'paintHotspot',
    value: function paintHotspot(context) {
      var image = this.props.image;


      var imageRect = new _shapes.Rect().setSize(image.width, image.height);

      var _getClampedValue = this.getClampedValue(),
          hotspot = _getClampedValue.hotspot,
          crop = _getClampedValue.crop;

      var scale = this.getScale();
      var margin = MARGIN_PX * scale;

      context.save();
      drawBackdrop();
      drawEllipse();
      context.clip();
      drawHole();
      context.restore();
      drawDragHandle(Math.PI * 1.25);

      function drawEllipse() {
        context.save();

        var dest = imageRect.shrink(margin).multiply(hotspot);

        var scaleY = dest.height / dest.width;

        context.scale(1, scaleY);
        context.beginPath();
        context.globalAlpha = 0.8;
        context.arc(dest.center.x, dest.center.y / scaleY, Math.abs(dest.width / 2), 0, 2 * Math.PI, false);
        context.strokeStyle = 'white';
        context.lineWidth = 1.5 * scale;
        context.stroke();
        context.closePath();

        context.restore();
      }

      function drawImage() {
        context.save();

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        context.drawImage.apply(context, [image].concat(args));
        context.restore();
      }

      function drawHole() {

        var src = imageRect.multiply(hotspot);

        var dest = imageRect.shrink(margin).multiply(hotspot);

        drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
      }

      function drawBackdrop() {

        var src = imageRect.cropRelative(crop);

        var dest = imageRect.shrink(margin).cropRelative(crop);

        context.save();
        drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
        context.globalAlpha = 0.5;
        context.fillStyle = 'black';
        context.fillRect(dest.left, dest.top, dest.width, dest.height);
        context.restore();
      }

      function drawDragHandle(radians) {
        context.save();

        var radius = HOTSPOT_HANDLE_SIZE * scale;
        var dest = imageRect.shrink(margin).multiply(hotspot);

        var point = utils2d.getPointAtCircumference(radians, dest);

        context.beginPath();
        context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
        context.fillStyle = 'rgb(255,255,255)';
        context.fill();
        context.closePath();
        context.restore();

        context.beginPath();
        context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
        context.strokeStyle = 'rgb(0, 0, 0)';
        context.lineWidth = 0.5 * scale;
        context.stroke();
        context.closePath();
      }
    }
  }, {
    key: 'getActualSize',
    value: function getActualSize() {
      var node = this.canvas.domNode;
      return { height: node.clientHeight, width: node.clientWidth };
    }
  }, {
    key: 'getDragHandleCoords',
    value: function getDragHandleCoords() {
      var bbox = this.getHotspotRect();
      var point = utils2d.getPointAtCircumference(Math.PI * 1.25, bbox);
      return {
        x: point.x,
        y: point.y,
        radius: 8 * this.getScale()
      };
    }
  }, {
    key: 'debug',
    value: function debug(context) {
      context.save();

      var image = this.props.image;


      var bbox = this.getHotspotRect();
      var scale = this.getScale();
      var margin = MARGIN_PX * scale;

      // IE 10 doesn't support context.setLineDash
      if (context.setLineDash) {
        context.setLineDash([2 * scale, 2 * scale]);
      }
      context.lineWidth = 0.5 * scale;

      context.strokeStyle = 'rgba(200, 200, 200, 0.5)';

      // --- center line x
      vline(bbox.center.x);
      // --- center line y
      hline(bbox.center.y);

      context.strokeStyle = 'rgba(150, 150, 150, 0.5)';
      // --- line top
      hline(bbox.top);

      // --- line bottom
      hline(bbox.bottom);

      // --- line left
      vline(bbox.left);
      // --- line right
      vline(bbox.right);

      context.restore();

      function vline(x) {
        line(x, margin, x, image.height - margin);
      }

      function hline(y) {
        line(margin, y, image.width - margin, y);
      }

      function line(x1, y1, x2, y2) {
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
        context.closePath();
      }
    }
  }, {
    key: 'paintBackground',
    value: function paintBackground(context) {
      var image = this.props.image;

      var inner = new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale());

      context.save();
      context.fillStyle = 'white';
      context.clearRect(0, 0, image.width, image.height);

      context.globalAlpha = 0.3;
      //context.globalCompositeOperation = 'lighten';

      context.drawImage(image, inner.left, inner.top, inner.width, inner.height);
      context.restore();
    }
  }, {
    key: 'paint',
    value: function paint(context) {
      context.save();

      var pxratio = this.state.devicePixelVsBackingStoreRatio;
      context.scale(pxratio, pxratio);

      this.paintBackground(context);
      //return context.restore();
      this.paintHotspot(context);
      //this.paintDragHandle(context);
      this.debug(context);
      this.paintCropBorder(context);

      if (this.state.mousePosition) {
        //this.paintMousePosition(context)
        this.highlightCropHandles(context);
      }

      context.restore();
    }
  }, {
    key: 'paintMousePosition',
    value: function paintMousePosition(context) {
      var _state$mousePosition = this.state.mousePosition,
          x = _state$mousePosition.x,
          y = _state$mousePosition.y;

      context.beginPath();
      context.arc(x, y, 14 * this.getScale(), 0, 2 * Math.PI, false);
      context.fillStyle = 'lightblue';
      context.fill();
      context.restore();
    }
  }, {
    key: 'paintCropBorder',
    value: function paintCropBorder(context) {
      var cropRect = this.getCropRect();
      context.save();
      context.beginPath();
      context.fillStyle = 'rgba(66, 66, 66, 0.9)';
      context.lineWidth = 1;
      context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height);
      context.stroke();
      context.closePath();
      context.restore();
    }
  }, {
    key: 'highlightCropHandles',
    value: function highlightCropHandles(context) {
      var _this2 = this;

      context.save();
      var crophandles = this.getCropHandles();

      //context.globalCompositeOperation = "difference";

      Object.keys(crophandles).forEach(function (handle) {
        context.fillStyle = _this2.state.cropping === handle ? 'rgba(202, 54, 53, 0.9)' : 'rgba(230, 230, 230, 0.9)';
        var _crophandles$handle = crophandles[handle],
            left = _crophandles$handle.left,
            top = _crophandles$handle.top,
            height = _crophandles$handle.height,
            width = _crophandles$handle.width;

        context.fillRect(left, top, width, height);
        context.beginPath();
        context.fillStyle = 'rgba(66, 66, 66, 0.9)';
        context.rect(left, top, width, height);
        context.closePath();
        context.stroke();
      });
      context.restore();
    }
  }, {
    key: 'getScale',
    value: function getScale() {
      var actualSize = this.getActualSize();
      return this.props.image.width / actualSize.width;
    }
  }, {
    key: 'getCursor',
    value: function getCursor() {
      var mousePosition = this.state.mousePosition;

      if (!mousePosition) {
        return 'auto';
      }

      var activeCropArea = this.state.cropping || this.getActiveCropHandleFor(mousePosition);
      if (activeCropArea) {
        return getCropCursorForHandle(activeCropArea);
      }

      var mouseOverDragHandle = utils2d.isPointInCircle(mousePosition, this.getDragHandleCoords());

      if (this.state.resizing || mouseOverDragHandle) {
        return 'move';
      }

      if (this.state.moving || this.state.cropMoving) {
        return 'url(' + cursors.CLOSE_HAND + '), move';
      }

      var mouseoverHotspot = utils2d.isPointInEllipse(mousePosition, this.getHotspotRect());
      var mouseoverCropRect = utils2d.isPointInRect(mousePosition, this.getCropRect());
      if (mouseoverHotspot || mouseoverCropRect) {
        return 'url(' + cursors.OPEN_HAND + '), move';
      }
      return 'auto';
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var domNode = this.canvas.domNode;
      var context = domNode.getContext('2d');
      this.paint(context);
      var currentCursor = domNode.style.cursor;
      var newCursor = this.getCursor();
      if (currentCursor != newCursor) {
        domNode.style.cursor = newCursor;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props$image = this.props.image,
          height = _props$image.height,
          width = _props$image.width;

      var ratio = this.state.devicePixelVsBackingStoreRatio;
      var style = {
        maxWidth: '100%',
        maxHeight: '100%',
        userSelect: 'none'
        // ,outline: '1px dotted cyan'
      };
      return _react2.default.createElement(DragAwareCanvas, {
        ref: this.setCanvas,
        onDrag: this.handleDrag,
        onDragStart: this.handleDragStart,
        onDragEnd: this.handleDragEnd,
        onMouseMove: this.handleMouseMove,
        onMouseOut: this.handleMouseOut,
        style: style,
        height: height * ratio,
        width: width * ratio
      });
    }
  }]);

  return ImageTool;
}(_react2.default.PureComponent);

ImageTool.propTypes = {
  value: _propTypes2.default.shape({
    hotspot: _propTypes2.default.shape({
      x: _propTypes2.default.number,
      y: _propTypes2.default.number,
      height: _propTypes2.default.number,
      width: _propTypes2.default.number
    })
  }),
  image: _propTypes2.default.shape({
    height: _propTypes2.default.number,
    width: _propTypes2.default.number
  }),
  onChange: _propTypes2.default.func
};
ImageTool.defaultProps = {
  onChange: function onChange() {}
};
exports.default = ImageTool;