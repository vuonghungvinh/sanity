'use strict';

var debug = require('debug')('sanity:import');
var pMap = require('p-map');

var _require = require('lodash'),
    get = _require.get;

var _require2 = require('@sanity/mutator'),
    extractWithPath = _require2.extractWithPath;

var serializePath = require('./serializePath');
var progressStepper = require('./util/progressStepper');

var STRENGTHEN_CONCURRENCY = 3;
var STRENGTHEN_BATCH_SIZE = 30;

function getStrongRefs(doc) {
  var refs = findStrongRefs(doc).map(serializePath);
  if (refs.length) {
    return {
      documentId: doc._id,
      references: refs
    };
  }

  return null;
}

// Note: mutates in-place
function weakenStrongRefs(doc) {
  var refs = findStrongRefs(doc);

  refs.forEach(function (item) {
    item.ref._weak = true;
  });

  return doc;
}

// Note: mutates in-place
function setTypeOnReferences(doc) {
  extractWithPath('..[_ref]', doc).map(function (match) {
    return match.path.slice(0, -1);
  }).map(function (path) {
    return { path, ref: get(doc, path) };
  }).filter(function (item) {
    return typeof item.ref._type === 'undefined';
  }).forEach(function (item) {
    item.ref._type = 'reference';
  });

  return doc;
}

function findStrongRefs(doc) {
  return extractWithPath('..[_ref]', doc).map(function (match) {
    return match.path.slice(0, -1);
  }).map(function (path) {
    return { path, ref: get(doc, path) };
  }).filter(function (item) {
    return item.ref._weak !== true;
  });
}

function strengthenReferences(strongRefs, options) {
  var client = options.client;


  var batches = [];
  for (var i = 0; i < strongRefs.length; i += STRENGTHEN_BATCH_SIZE) {
    batches.push(strongRefs.slice(i, i + STRENGTHEN_BATCH_SIZE));
  }

  var progress = progressStepper(options.onProgress, {
    step: 'Strengthening references',
    total: batches.length
  });

  var mapOptions = { concurrency: STRENGTHEN_CONCURRENCY };
  return pMap(batches, unsetWeakBatch.bind(null, client, progress), mapOptions);
}

function unsetWeakBatch(client, progress, batch) {
  debug('Strengthening batch of %d documents', batch.length);
  return batch.reduce(reducePatch, client.transaction()).commit({ visibility: 'async' }).then(progress).then(function (res) {
    return res.results.length;
  });
}

function reducePatch(trx, task) {
  return trx.patch(task.documentId, function (patch) {
    return patch.unset(task.references.map(function (path) {
      return `${path}._weak`;
    }));
  });
}

exports.getStrongRefs = getStrongRefs;
exports.weakenStrongRefs = weakenStrongRefs;
exports.setTypeOnReferences = setTypeOnReferences;
exports.strengthenReferences = strengthenReferences;