'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

exports.getTypeProblems = getTypeProblems;
exports.default = groupProblems;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function createTypeWithMembersProblemsAccessor(memberPropertyName) {
  var getMembers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (type) {
    return type[memberPropertyName];
  };

  return function getProblems(type, parentPath) {
    var currentPath = [].concat(_toConsumableArray(parentPath), [{ kind: 'type', type: type.type, name: type.name }]);
    var members = getMembers(type) || [];

    var memberProblems = members.map(function (memberType) {
      var memberPath = [].concat(_toConsumableArray(currentPath), [{ kind: 'property', name: memberPropertyName }]);
      return getTypeProblems(memberType, memberPath);
    });

    return [{
      path: currentPath,
      problems: type._problems || []
    }].concat(_toConsumableArray((0, _flatten3.default)(memberProblems)));
  };
}

var arrify = function arrify(val) {
  return Array.isArray(val) ? val : typeof val === 'undefined' && [] || [val];
};

var getObjectProblems = createTypeWithMembersProblemsAccessor('fields');
var getArrayProblems = createTypeWithMembersProblemsAccessor('of');
var getReferenceProblems = createTypeWithMembersProblemsAccessor('to', function (type) {
  return arrify(type.to);
});

function getDefaultProblems(type) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  return [{
    path: [].concat(_toConsumableArray(path), [{ kind: 'type', type: type.type, name: type.name }]),
    problems: type._problems || []
  }];
}

function getTypeProblems(type) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  switch (type.type) {
    case 'object':
      {
        return getObjectProblems(type, path);
      }
    case 'document':
      {
        return getObjectProblems(type, path);
      }
    case 'array':
      {
        return getArrayProblems(type, path);
      }
    case 'reference':
      {
        return getReferenceProblems(type, path);
      }
    default:
      {
        return getDefaultProblems(type, path);
      }
  }
}

function groupProblems(types) {
  return (0, _flatten3.default)(types.map(getTypeProblems)).filter(function (type) {
    return type.problems.length > 0;
  });
}