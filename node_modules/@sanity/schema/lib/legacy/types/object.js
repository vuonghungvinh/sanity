'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectType = undefined;

var _startCase2 = require('lodash/startCase');

var _startCase3 = _interopRequireDefault(_startCase2);

var _keyBy2 = require('lodash/keyBy');

var _keyBy3 = _interopRequireDefault(_keyBy2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = require('./utils');

var _createPreviewGetter = require('../preview/createPreviewGetter');

var _createPreviewGetter2 = _interopRequireDefault(_createPreviewGetter);

var _guessOrderingConfig = require('../ordering/guessOrderingConfig');

var _guessOrderingConfig2 = _interopRequireDefault(_guessOrderingConfig);

var _resolveSearchFields = require('../resolveSearchFields');

var _resolveSearchFields2 = _interopRequireDefault(_resolveSearchFields);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var OVERRIDABLE_FIELDS = ['jsonType', 'orderings', 'type', 'name', 'title', 'readOnly', 'hidden', 'description', '__unstable_searchFields', 'options', 'inputComponent'];

var ObjectType = {
  get: function get() {
    return {
      name: 'object',
      type: null,
      jsonType: 'object'
    };
  },
  extend: function extend(rawSubTypeDef, createMemberType) {

    var subTypeDef = _extends({ fields: [] }, rawSubTypeDef);

    var options = _extends({}, subTypeDef.options || {});
    var parsed = Object.assign((0, _pick3.default)(this.get(), OVERRIDABLE_FIELDS), subTypeDef, {
      type: this.get(),
      title: subTypeDef.title || (subTypeDef.name ? (0, _startCase3.default)(subTypeDef.name) : ''),
      options: options,
      orderings: subTypeDef.orderings || (0, _guessOrderingConfig2.default)(subTypeDef),
      fields: subTypeDef.fields.map(function (fieldDef) {
        var name = fieldDef.name,
            fieldset = fieldDef.fieldset,
            rest = _objectWithoutProperties(fieldDef, ['name', 'fieldset']);

        var compiledField = {
          name: name,
          fieldset: fieldset
        };

        return (0, _utils.lazyGetter)(compiledField, 'type', function () {
          return createMemberType(_extends({}, rest, {
            title: fieldDef.title || (0, _startCase3.default)(name)
          }));
        });
      })
    });

    (0, _utils.lazyGetter)(parsed, 'fieldsets', function () {
      return createFieldsets(subTypeDef, parsed.fields);
    });

    (0, _utils.lazyGetter)(parsed, 'preview', (0, _createPreviewGetter2.default)(subTypeDef));

    (0, _utils.lazyGetter)(parsed, '__unstable_searchFields', function () {
      return (0, _resolveSearchFields2.default)(parsed);
    }, { enumerable: false });

    return subtype(parsed);

    function subtype(parent) {
      return {
        get: function get() {
          return parent;
        },

        extend: function extend(extensionDef) {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "object"');
          }
          var current = Object.assign({}, parent, (0, _pick3.default)(extensionDef, OVERRIDABLE_FIELDS), {
            title: extensionDef.title || subTypeDef.title,
            type: parent
          });
          (0, _utils.lazyGetter)(current, '__unstable_searchFields', function () {
            return parent.__unstable_searchFields;
          });
          return subtype(current);
        }
      };
    }
  }
};

exports.ObjectType = ObjectType;
function createFieldsets(typeDef, fields) {
  var fieldsetsDef = typeDef.fieldsets || [];
  var fieldsets = fieldsetsDef.map(function (fieldset) {
    var name = fieldset.name,
        title = fieldset.title,
        description = fieldset.description,
        options = fieldset.options;

    return {
      name: name,
      title: title,
      description: description,
      options: options,
      fields: []
    };
  });

  var fieldsetsByName = (0, _keyBy3.default)(fieldsets, 'name');

  return fields.map(function (field) {
    if (field.fieldset) {
      var fieldset = fieldsetsByName[field.fieldset];
      if (!fieldset) {
        throw new Error('Group \'' + field.fieldset + '\' is not defined in schema for type \'' + typeDef.name + '\'');
      }
      fieldset.fields.push(field);
      // Return the fieldset if its the first time we encounter a field in this fieldset
      return fieldset.fields.length === 1 ? fieldset : null;
    }
    return { single: true, field: field };
  }).filter(Boolean);
}