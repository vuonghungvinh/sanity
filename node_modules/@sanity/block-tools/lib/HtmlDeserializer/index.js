'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _helpers = require('./helpers');

var _rules = require('./rules');

var _rules2 = _interopRequireDefault(_rules);

var _resolveJsType = require('../util/resolveJsType');

var _resolveJsType2 = _interopRequireDefault(_resolveJsType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A internal variable to keep track of annotation mark definitions within the 'run' of a block
 *
 */
var _markDefsWithinBlock = [];

/**
 * HTML Deserializer
 *
 */

var HtmlDeserializer =

/**
 * Create a new serializer respecting a Sanity block content type's schema
 *
 * @param {Object} options
 *   @property {Object} blockContentType
 *      A compiled version of the block content schema type
 *   @property {Array} rules
 *      Optional rules working on the HTML (will be ruled first)
 *   @property {Function} parseHtml
 *      API compatible model as returned from DOMParser for using server side.
 */

function HtmlDeserializer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, HtmlDeserializer);

  _initialiseProps.call(this);

  var _options$rules = options.rules,
      rules = _options$rules === undefined ? [] : _options$rules;

  var blockContentType = options.blockContentType;
  var standardRules = (0, _rules2.default)(blockContentType, (0, _helpers.createRuleOptions)(blockContentType));
  this.rules = [].concat(_toConsumableArray(rules), _toConsumableArray(standardRules));
  var parseHtml = options.parseHtml || (0, _helpers.defaultParseHtml)();
  this.parseHtml = function (html) {
    var doc = (0, _helpers.preprocess)(html, parseHtml);
    return doc.body;
  };
}

/**
 * Deserialize HTML.
 *
 * @param {String} html
 * @return {Array}
 */

/**
 * Deserialize an array of DOM elements.
 *
 * @param {Array} elements
 * @return {Array}
 */

/**
 * Deserialize a DOM element.
 *
 * @param {Object} element
 * @return {Any}
 */

/**
 * Deserialize a `__decorator` type
 * (an internal made up type to process decorators exclusively)
 *
 * @param {Object} decorator
 * @return {Array}
 */

/**
 * Deserialize a `__annotation` object.
 * (an internal made up type to process annotations exclusively)
 *
 * @param {Object} annotation
 * @return {Array}
 */

;

var _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.deserialize = function (html) {
    var parseHtml = _this.parseHtml;

    var fragment = parseHtml(html);
    var children = Array.from(fragment.childNodes);
    var blocks = _this.deserializeElements(children);
    // Ensure that all top-level objects are wrapped into a block
    blocks = (0, _helpers.ensureRootIsBlocks)(blocks);
    // Ensure that there are no blocks within blocks, and trim whitespace
    return (0, _helpers.trimWhitespace)((0, _helpers.flattenNestedBlocks)(blocks));
  };

  this.deserializeElements = function () {
    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var nodes = [];
    elements.forEach(function (element, index) {
      var node = _this.deserializeElement(element);
      switch ((0, _resolveJsType2.default)(node)) {
        case 'array':
          nodes = nodes.concat(node);
          break;
        case 'object':
          nodes.push(node);
          break;
        default:
          throw new Error('Don\'t know what to do with: ' + JSON.stringify(node));
      }
    });
    return nodes;
  };

  this.deserializeElement = function (element) {
    // eslint-disable-line complexity

    var node = void 0;
    if (!element.tagName) {
      element.tagName = '';
    }

    var next = function next(elements) {
      var _elements = elements;
      if (Object.prototype.toString.call(_elements) == '[object NodeList]') {
        _elements = Array.from(_elements);
      }

      switch ((0, _resolveJsType2.default)(_elements)) {
        case 'array':
          return _this.deserializeElements(_elements);
        case 'object':
          return _this.deserializeElement(_elements);
        case 'null':
        case 'undefined':
          return undefined;
        default:
          throw new Error('The `next` argument was called with invalid children: "' + _elements + '".');
      }
    };

    var _loop = function _loop(i) {
      var rule = _this.rules[i];
      if (!rule.deserialize) {
        return 'continue';
      }
      var ret = rule.deserialize(element, next);
      var type = (0, _resolveJsType2.default)(ret);

      if (type != 'array' && type != 'object' && type != 'null' && type != 'undefined') {
        throw new Error('A rule returned an invalid deserialized representation: "' + node + '".');
      }

      if (ret === undefined) {
        return 'continue';
      } else if (ret === null) {
        return {
          v: null
        };
      } else if (ret._type === '__decorator') {
        node = _this.deserializeDecorator(ret);
      } else if (ret._type === '__annotation') {
        node = _this.deserializeAnnotation(ret);
      } else if (ret._type === 'block' && _markDefsWithinBlock.length) {
        ret.markDefs = _markDefsWithinBlock;
        _markDefsWithinBlock = []; // Reset here
        node = ret;
      } else {
        node = ret;
      }
      // Set list level on list item
      if (ret && ret._type === 'block' && ret.listItem) {
        var parent = element.parentNode.parentNode;
        while ((0, _helpers.tagName)(parent) === 'li') {
          parent = parent.parentNode.parentNode;
          ret.level++;
        }
      }
      // Set newlines on spans orginating from a block element within a blockquote
      if (ret && ret._type === 'block' && ret.style === 'blockquote') {
        ret.children.forEach(function (child, index) {
          if (child._type === 'span' && child.text === '\r') {
            child.text = '\n\n';
            if (index === 0 || index === ret.children.length - 1) {
              ret.children.splice(index, 1);
            }
          }
        });
      }
      return 'break';
    };

    _loop2: for (var i = 0; i < _this.rules.length; i++) {
      var _ret = _loop(i);

      switch (_ret) {
        case 'continue':
          continue;

        case 'break':
          break _loop2;

        default:
          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
    }

    return node || next(element.childNodes);
  };

  this.deserializeDecorator = function (decorator) {
    var name = decorator.name;

    var applyDecorator = function applyDecorator(node) {
      if (node._type === '__decorator') {
        return _this.deserializeDecorator(node);
      } else if (node._type === 'span') {
        node.marks = node.marks || [];
        if (node.text.trim()) {
          // Only apply marks if this is an actual text
          node.marks.unshift(name);
        }
      } else if (node.children) {
        node.children = node.children.map(applyDecorator);
      }
      return node;
    };
    return decorator.children.reduce(function (children, node) {
      var ret = applyDecorator(node);
      if (Array.isArray(ret)) {
        return children.concat(ret);
      }
      children.push(ret);
      return children;
    }, []);
  };

  this.deserializeAnnotation = function (annotation) {
    var markDef = annotation.markDef;

    _markDefsWithinBlock.push(markDef);
    var applyAnnotation = function applyAnnotation(node) {
      if (node._type === '__annotation') {
        return _this.deserializeAnnotation(node);
      } else if (node._type === 'span') {
        node.marks = node.marks || [];
        if (node.text.trim()) {
          // Only apply marks if this is an actual text
          node.marks.unshift(markDef._key);
        }
      } else if (node.children) {
        node.children = node.children.map(applyAnnotation);
      }
      return node;
    };
    return annotation.children.reduce(function (children, node) {
      var ret = applyAnnotation(node);
      if (Array.isArray(ret)) {
        return children.concat(ret);
      }
      children.push(ret);
      return children;
    }, []);
  };
};

exports.default = HtmlDeserializer;