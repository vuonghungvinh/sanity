'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simpleGet = require('simple-get');

var _simpleGet2 = _interopRequireDefault(_simpleGet);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _import = require('@sanity/import');

var _import2 = _interopRequireDefault(_import);

var _padStart = require('lodash/padStart');

var _padStart2 = _interopRequireDefault(_padStart);

var _prettyMs = require('pretty-ms');

var _prettyMs2 = _interopRequireDefault(_prettyMs);

var _promise = require('linecount/promise');

var _promise2 = _interopRequireDefault(_promise);

var _chooseDatasetPrompt = require('../../actions/dataset/chooseDatasetPrompt');

var _chooseDatasetPrompt2 = _interopRequireDefault(_chooseDatasetPrompt);

var _debug = require('../../debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'import',
  group: 'dataset',
  signature: '[FILE] [TARGET_DATASET]',
  description: 'Import dataset from local filesystem',
  action: (() => {
    var _ref = _asyncToGenerator(function* (args, context) {
      const apiClient = context.apiClient,
            output = context.output,
            chalk = context.chalk,
            prompt = context.prompt;


      let spinner = null;
      const operation = getMutationOperation(args.extOptions);
      const client = apiClient();

      var _args$argsWithoutOpti = _slicedToArray(args.argsWithoutOptions, 2);

      const file = _args$argsWithoutOpti[0],
            target = _args$argsWithoutOpti[1];

      if (!file) {
        throw new Error(`Source file name and target dataset must be specified ("sanity dataset import ${chalk.bold('[file]')} [dataset]")`);
      }

      (0, _debug2.default)('[  0%] Fetching available datasets');
      spinner = output.spinner('Fetching available datasets').start();
      const datasets = yield client.datasets.list();
      spinner.succeed('[100%] Fetching available datasets');

      let targetDataset = target ? `${target}` : null;
      if (!targetDataset) {
        targetDataset = yield (0, _chooseDatasetPrompt2.default)(context, {
          message: 'Select target dataset',
          allowCreation: true
        });
      } else if (!datasets.find(function (dataset) {
        return dataset.name === targetDataset;
      })) {
        (0, _debug2.default)('Target dataset does not exist, prompting for creation');
        const shouldCreate = yield prompt.single({
          type: 'confirm',
          message: `Dataset "${targetDataset}" does not exist, would you like to create it?`,
          default: true
        });

        if (!shouldCreate) {
          throw new Error(`Dataset "${targetDataset}" does not exist`);
        }

        yield client.datasets.create(targetDataset);
      }

      (0, _debug2.default)(`Target dataset has been set to "${targetDataset}"`);

      const isUrl = /^https?:\/\//i.test(file);
      const sourceFile = isUrl ? file : _path2.default.resolve(process.cwd(), file);
      const inputSource = isUrl ? getUrlStream(sourceFile) : _fsExtra2.default.createReadStream(sourceFile);
      const inputStream = yield inputSource;

      const documentCount = isUrl ? 0 : yield (0, _promise2.default)(sourceFile);
      (0, _debug2.default)(documentCount ? 'Could not count documents in source' : `Found ${documentCount} lines in source file`);

      const importClient = client.clone().config({ dataset: targetDataset });

      let currentStep;
      let currentProgress;
      let stepStart;
      let spinInterval;
      let percent;

      function onProgress(opts) {
        const lengthComputable = opts.total;
        const sameStep = opts.step == currentStep;
        percent = getPercentage(opts);

        if (lengthComputable && opts.total === opts.current) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        if (sameStep) {
          return;
        }

        // Moved to a new step
        const prevStep = currentStep;
        const prevStepStart = stepStart || Date.now();
        stepStart = Date.now();
        currentStep = opts.step;

        if (currentProgress && currentProgress.succeed) {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${prevStep} (${timeSpent})`;
          currentProgress.succeed();
        }

        currentProgress = output.spinner(`[0%] ${opts.step} (0.00s)`).start();

        if (spinInterval) {
          clearInterval(spinInterval);
          spinInterval = null;
        }

        spinInterval = setInterval(() => {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - prevStepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `${percent}${opts.step} (${timeSpent})`;
        }, 60);
      }

      function endTask(_ref2) {
        let success = _ref2.success;

        clearInterval(spinInterval);
        spinInterval = null;

        if (success) {
          const timeSpent = (0, _prettyMs2.default)(Date.now() - stepStart, {
            secDecimalDigits: 2
          });
          currentProgress.text = `[100%] ${currentStep} (${timeSpent})`;
          currentProgress.succeed();
        } else {
          currentProgress.fail();
        }
      }

      // Start the import!
      try {
        const imported = yield (0, _import2.default)(inputStream, {
          client: importClient,
          operation: operation,
          onProgress: onProgress
        });

        endTask({ success: true });

        output.print('Done! Imported %d documents to dataset "%s"', imported, targetDataset);
      } catch (err) {
        endTask({ success: false });

        let error = err.message;
        if (err.response && err.response.statusCode === 409) {
          error = [err.message, '', 'You probably want either:', ' --replace (replace existing documents with same IDs)', ' --missing (only import documents that do not already exist)'].join('\n');
        }

        output.error(chalk.red(`\n${error}\n`));
      }
    });

    return function action(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })()
};


function getMutationOperation(flags) {
  const replace = flags.replace,
        missing = flags.missing;

  if (replace && missing) {
    throw new Error('Cannot use both --replace and --missing');
  }

  if (flags.replace) {
    return 'createOrReplace';
  }

  if (flags.missing) {
    return 'createIfNotExists';
  }

  return 'create';
}

function getPercentage(opts) {
  if (!opts.total) {
    return '';
  }

  const percent = Math.floor(opts.current / opts.total * 100);
  return `[${(0, _padStart2.default)(percent, 3, ' ')}%] `;
}

function getUrlStream(url) {
  return new Promise((resolve, reject) => {
    (0, _simpleGet2.default)(url, (err, res) => err ? reject(err) : resolve(res));
  });
}