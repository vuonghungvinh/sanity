'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _pathExists = require('path-exists');

var _pathExists2 = _interopRequireDefault(_pathExists);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _resolver = require('@sanity/resolver');

var _resolver2 = _interopRequireDefault(_resolver);

var _normalizePluginName = require('../../util/normalizePluginName');

var _normalizePluginName2 = _interopRequireDefault(_normalizePluginName);

var _generateConfigChecksum = require('../../util/generateConfigChecksum');

var _generateConfigChecksum2 = _interopRequireDefault(_generateConfigChecksum);

var _pluginChecksumManifest = require('../../util/pluginChecksumManifest');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (() => {
  var _ref = _asyncToGenerator(function* (options) {
    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const workDir = options.workDir,
          output = options.output;


    const localChecksums = yield (0, _pluginChecksumManifest.getChecksums)(workDir);
    const allPlugins = yield (0, _resolver2.default)({ basePath: workDir });
    const pluginsWithDistConfig = (yield Promise.all(allPlugins.map(pluginHasDistConfig))).filter(Boolean);
    const distChecksums = yield Promise.all(pluginsWithDistConfig.map(getPluginConfigChecksum));
    const withLocalConfigs = yield Promise.all(distChecksums.map(hasLocalConfig));
    const missingConfigs = yield Promise.all(withLocalConfigs.map(createMissingConfig));
    const configPlugins = missingConfigs.map(warnOnDifferingChecksum);

    return missingConfigs.length > 0 ? saveNewChecksums(configPlugins) : Promise.resolve();

    function hasLocalConfig(plugin) {
      return (0, _pluginChecksumManifest.localConfigExists)(workDir, plugin.name).then(configDeployed => Object.assign({}, plugin, { configDeployed: configDeployed }));
    }

    function createMissingConfig(plugin) {
      if (plugin.configDeployed) {
        return plugin;
      }

      const srcPath = _path2.default.join(plugin.path, 'config.dist.json');
      const dstPath = _path2.default.join(workDir, 'config', `${(0, _normalizePluginName2.default)(plugin.name)}.json`);
      const prtPath = _path2.default.relative(workDir, dstPath);

      if (!flags.quiet) {
        output.print(`Plugin "${plugin.name}" is missing local configuration file, creating ${prtPath}`);
      }

      return _fsExtra2.default.copy(srcPath, dstPath).then(() => plugin);
    }

    function warnOnDifferingChecksum(plugin) {
      if (flags.quiet) {
        return plugin;
      }

      const local = localChecksums[plugin.name];
      if (typeof local !== 'undefined' && local !== plugin.configChecksum) {
        const name = (0, _normalizePluginName2.default)(plugin.name);
        output.print(`[WARN] Default configuration file for plugin "${name}" has changed since local copy was created`);
      }

      return plugin;
    }

    function saveNewChecksums(plugins) {
      const sums = Object.assign({}, localChecksums);
      plugins.forEach(plugin => {
        if (!sums[plugin.name]) {
          sums[plugin.name] = plugin.configChecksum;
        }
      });

      return (0, _pluginChecksumManifest.setChecksums)(workDir, sums);
    }
  });

  function reinitializePluginConfigs(_x) {
    return _ref.apply(this, arguments);
  }

  return reinitializePluginConfigs;
})();

function getPluginConfigPath(plugin) {
  return _path2.default.join(plugin.path, 'config.dist.json');
}

function pluginHasDistConfig(plugin) {
  const configPath = getPluginConfigPath(plugin);
  return (0, _pathExists2.default)(configPath).then(exists => exists && plugin);
}

function getPluginConfigChecksum(plugin) {
  return (0, _generateConfigChecksum2.default)(getPluginConfigPath(plugin)).then(configChecksum => Object.assign({}, plugin, { configChecksum: configChecksum }));
}