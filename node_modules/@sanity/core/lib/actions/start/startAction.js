'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _thenify = require('thenify');

var _thenify2 = _interopRequireDefault(_thenify);

var _server = require('@sanity/server');

var _getConfig = require('@sanity/util/lib/getConfig');

var _getConfig2 = _interopRequireDefault(_getConfig);

var _isProduction = require('../../util/isProduction');

var _isProduction2 = _interopRequireDefault(_isProduction);

var _reinitializePluginConfigs = require('../../actions/config/reinitializePluginConfigs');

var _reinitializePluginConfigs2 = _interopRequireDefault(_reinitializePluginConfigs);

var _checkReactCompatibility = require('../../util/checkReactCompatibility');

var _checkReactCompatibility2 = _interopRequireDefault(_checkReactCompatibility);

var _formatMessage = require('./formatMessage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (() => {
  var _ref = _asyncToGenerator(function* (args, context) {
    const flags = args.extOptions;
    const output = context.output,
          workDir = context.workDir;

    const sanityConfig = (0, _getConfig2.default)(workDir);
    const config = sanityConfig.get('server');
    const getServer = _isProduction2.default ? _server.getProdServer : _server.getDevServer;
    const port = config.port,
          hostname = config.hostname;

    const httpHost = flags.host === 'all' ? '0.0.0.0' : flags.host || hostname;
    const httpPort = flags.port || port;

    const serverOptions = {
      staticPath: resolveStaticPath(workDir, config),
      basePath: workDir,
      httpHost: httpHost,
      httpPort: httpPort,
      context: context,
      project: sanityConfig.get('project')
    };

    (0, _checkReactCompatibility2.default)(workDir);

    let compileSpinner;
    const configSpinner = output.spinner('Checking configuration files...');
    try {
      yield (0, _reinitializePluginConfigs2.default)({ workDir: workDir, output: output });
    } catch (err) {
      if (err.code !== 'PluginNotFound') {
        throw err;
      }

      const manifest = yield _fsExtra2.default.readJson(_path2.default.join(workDir, 'package.json')).catch(function () {
        return {};
      });
      const dependencies = Object.keys(Object.assign({}, manifest.dependencies, manifest.devDependencies));
      const depName = err.plugin[0] === '@' ? err.plugin : `sanity-plugin-${err.plugin}`;
      if (dependencies.includes(depName)) {
        err.message = `${err.message}\n\nTry running "sanity install"?`;
      } else {
        err.message = `${err.message}\n\nTry running "sanity install ${depName}"?`;
      }

      throw err;
    }

    configSpinner.succeed();

    const server = getServer(serverOptions);
    const compiler = server.locals.compiler;

    // "invalid" doesn't mean the bundle is invalid, but that it is *invalidated*,
    // in other words, it's recompiling
    compiler.plugin('invalid', function () {
      output.clear();
      resetSpinner();
    });

    // Start the server and try to create more user-friendly errors if we encounter issues
    try {
      yield (0, _thenify2.default)(server.listen.bind(server))(httpPort, httpHost);
    } catch (err) {
      gracefulDeath(httpHost, config, err);
    }

    // Hold off on showing the spinner until compilation has started
    compiler.plugin('compile', function () {
      return resetSpinner();
    });

    // "done" event fires when Webpack has finished recompiling the bundle.
    // Whether or not you have warnings or errors, you will get this event.

    compiler.plugin('done', function (stats) {
      if (compileSpinner) {
        compileSpinner.succeed();
      }

      const hasErrors = stats.hasErrors();
      const hasWarnings = stats.hasWarnings();

      if (!hasErrors && !hasWarnings) {
        output.print(_chalk2.default.green(`Compiled successfully! Server listening on http://${httpHost}:${httpPort}`));
        return;
      }

      var _stats$toJson = stats.toJson({}, true);

      const errors = _stats$toJson.errors,
            warnings = _stats$toJson.warnings;


      if (hasErrors) {
        printErrors(output, errors);
        return; // If errors exist, ignore warnings.
      }

      if (hasWarnings) {
        printWarnings(output, warnings);
      }

      output.print(_chalk2.default.green(`Server listening on http://${httpHost}:${httpPort}`));
    });

    function resetSpinner() {
      if (compileSpinner) {
        compileSpinner.stop();
      }

      compileSpinner = output.spinner('Compiling...').start();
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

function resolveStaticPath(rootDir, config) {
  const staticPath = config.staticPath;

  return _path2.default.isAbsolute(staticPath) ? staticPath : _path2.default.resolve(_path2.default.join(rootDir, staticPath));
}

function gracefulDeath(httpHost, config, err) {
  if (err.code === 'EADDRINUSE') {
    throw new Error('Port number for Sanity server is already in use, configure `server.port` in `sanity.json`');
  }

  if (err.code === 'EACCES') {
    const help = config.port < 1024 ? 'port numbers below 1024 requires root privileges' : `do you have access to listen to the given host (${httpHost})?`;

    throw new Error(`Sanity server does not have access to listen to given port - ${help}`);
  }

  throw err;
}

function printErrors(output, errors) {
  output.print(_chalk2.default.red('Failed to compile.'));
  output.print('');

  const formattedErrors = (errors.some(_formatMessage.isLikelyASyntaxError) ? errors.filter(_formatMessage.isLikelyASyntaxError) : errors).map(message => `Error in ${(0, _formatMessage.formatMessage)(message)}`);

  formattedErrors.forEach(message => {
    output.print(message);
    output.print('');
  });
}

function printWarnings(output, warnings) {
  output.print(_chalk2.default.yellow('Compiled with warnings.'));
  output.print();

  warnings.map(message => `Warning in ${(0, _formatMessage.formatMessage)(message)}`).forEach(message => {
    output.print(message);
    output.print();
  });
}