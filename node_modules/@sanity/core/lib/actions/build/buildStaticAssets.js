'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _rimraf = require('rimraf');

var _rimraf2 = _interopRequireDefault(_rimraf);

var _thenify = require('thenify');

var _thenify2 = _interopRequireDefault(_thenify);

var _filesize = require('filesize');

var _filesize2 = _interopRequireDefault(_filesize);

var _compressJavascript = require('./compressJavascript');

var _compressJavascript2 = _interopRequireDefault(_compressJavascript);

var _getConfig = require('@sanity/util/lib/getConfig');

var _getConfig2 = _interopRequireDefault(_getConfig);

var _sortModulesBySize = require('../../stats/sortModulesBySize');

var _sortModulesBySize2 = _interopRequireDefault(_sortModulesBySize);

var _checkReactCompatibility = require('../../util/checkReactCompatibility');

var _checkReactCompatibility2 = _interopRequireDefault(_checkReactCompatibility);

var _server = require('@sanity/server');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const rimraf = (0, _thenify2.default)(_rimraf2.default);
const absoluteMatch = /^https?:\/\//i;

exports.default = (() => {
  var _ref = _asyncToGenerator(function* (args, context) {
    const output = context.output,
          prompt = context.prompt,
          workDir = context.workDir;

    const flags = args.extOptions;
    const defaultOutputDir = _path2.default.resolve(_path2.default.join(workDir, 'dist'));
    const outputDir = _path2.default.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
    const config = (0, _getConfig2.default)(workDir);
    const compilationConfig = {
      env: 'production',
      staticPath: resolveStaticPath(workDir, config.get('server')),
      basePath: workDir,
      outputPath: _path2.default.join(outputDir, 'static'),
      sourceMaps: flags['source-maps'],
      skipMinify: flags['skip-minify'] || false,
      profile: flags.profile || false
    };

    (0, _checkReactCompatibility2.default)(workDir);

    const compiler = (0, _server.getWebpackCompiler)(compilationConfig);
    const compile = (0, _thenify2.default)(compiler.run.bind(compiler));
    let shouldDelete = true;

    if (outputDir !== defaultOutputDir) {
      shouldDelete = yield prompt.single({
        type: 'confirm',
        message: `Do you want to delete the existing directory (${outputDir}) first?`,
        default: true
      });
    }

    let spin;

    if (shouldDelete) {
      const deleteStart = Date.now();
      spin = output.spinner('Clearing output folder').start();
      yield rimraf(outputDir);
      spin.text = `Clearing output folder (${Date.now() - deleteStart}ms)`;
      spin.succeed();
    }

    spin = output.spinner('Building Sanity').start();

    const bundle = {};

    try {
      // Compile the bundle
      const statistics = yield compile();
      const stats = statistics.toJson();
      if (stats.errors && stats.errors.length > 0) {
        throw new Error(`Errors while building:\n\n${stats.errors.join('\n\n')}`);
      }

      spin.text = `Building Sanity (${stats.time}ms)`;
      spin.succeed();

      // Get hashes for each chunk
      const chunkMap = {};
      stats.chunks.forEach(function (chunk) {
        return chunk.files.forEach(function (file) {
          chunkMap[file] = chunk.hash;
        });
      });

      bundle.stats = stats;

      if (flags.profile) {
        yield _fsExtra2.default.writeFile(_path2.default.join(workDir, 'build-stats.json'), JSON.stringify(statistics.toJson('verbose')));
      }

      // Build new index document with correct hashes
      const indexStart = Date.now();
      spin = output.spinner('Building index document').start();
      const doc = yield (0, _server.getDocumentElement)(_extends({}, compilationConfig, { hashes: chunkMap, project: config.get('project') }), {
        scripts: ['vendor.bundle.js', 'app.bundle.js'].map(function (asset) {
          const assetPath = absoluteMatch.test(asset) ? asset : `js/${asset}`;
          return {
            path: assetPath,
            hash: chunkMap[assetPath] || chunkMap[asset]
          };
        })
      });

      // Write index file to output destination
      yield _fsExtra2.default.writeFile(_path2.default.join(outputDir, 'index.html'), `<!doctype html>${_server.ReactDOM.renderToStaticMarkup(doc)}`);

      // Print build output, optionally stats if requested
      bundle.stats.warnings.forEach(output.print);
      spin.text = `Building index document (${Date.now() - indexStart}ms)`;
      spin.succeed();

      if (flags.stats) {
        output.print('\nLargest modules (unminified, uncompressed sizes):');
        (0, _sortModulesBySize2.default)(bundle.stats.modules).slice(0, 10).forEach(function (module) {
          return output.print(`[${(0, _filesize2.default)(module.size)}] ${module.name}`);
        });
      }

      // Now compress the JS bundles
      if (!compilationConfig.skipMinify) {
        spin = output.spinner('Minifying Javascript bundles').start();
        const compressStart = Date.now();
        yield Promise.all(Object.keys(chunkMap).filter(function (fileName) {
          return _path2.default.extname(fileName) === '.js';
        }).map(function (fileName) {
          return _path2.default.join(compilationConfig.outputPath, fileName);
        }).map(_compressJavascript2.default));

        spin.text = `Minifying Javascript bundles (${Date.now() - compressStart}ms)`;
        spin.succeed();
      }

      // Copy static assets (from /static folder) to output dir
      yield _fsExtra2.default.copy(_path2.default.join(workDir, 'static'), _path2.default.join(outputDir, 'static'), { overwrite: false });
    } catch (err) {
      spin.fail();
      throw err;
    }

    return bundle;
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

function resolveStaticPath(rootDir, config) {
  const staticPath = config.staticPath;

  return _path2.default.isAbsolute(staticPath) ? staticPath : _path2.default.resolve(_path2.default.join(rootDir, staticPath));
}