'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

let checkDir = (() => {
  var _ref2 = _asyncToGenerator(function* (sourceDir) {
    try {
      const stats = yield _fsExtra2.default.stat(sourceDir);
      if (!stats.isDirectory()) {
        throw new Error(`Directory ${sourceDir} is not a directory`);
      }
    } catch (err) {
      const error = err.code === 'ENOENT' ? new Error(`Directory "${sourceDir}" does not exist`) : err;

      throw error;
    }

    try {
      yield _fsExtra2.default.stat(_path2.default.join(sourceDir, 'index.html'));
    } catch (err) {
      const error = err.code === 'ENOENT' ? new Error([`"${sourceDir}/index.html" does not exist -`, '[SOURCE_DIR] must be a directory containing', 'a Sanity studio built using "sanity build"'].join(' ')) : err;

      throw error;
    }
  });

  return function checkDir(_x3) {
    return _ref2.apply(this, arguments);
  };
})();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _tarFs = require('tar-fs');

var _tarFs2 = _interopRequireDefault(_tarFs);

var _lazyRequire = require('@sanity/util/lib/lazyRequire');

var _lazyRequire2 = _interopRequireDefault(_lazyRequire);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (() => {
  var _ref = _asyncToGenerator(function* (args, context) {
    const apiClient = context.apiClient,
          workDir = context.workDir,
          chalk = context.chalk,
          output = context.output,
          prompt = context.prompt;

    const flags = Object.assign({ build: true }, args.extOptions);
    const sourceDir = _path2.default.resolve(process.cwd(), args.argsWithoutOptions[0] || _path2.default.join(workDir, 'dist'));

    const client = apiClient({
      requireUser: true,
      requireProject: true
    });

    // Check that the project has a studio hostname
    let spinner = output.spinner('Checking project info').start();
    const project = yield client.projects.getById(client.config().projectId);
    let studioHostname = project && (project.studioHostname || project.studioHost);
    spinner.succeed();

    if (!studioHostname) {
      output.print('Your project has not been assigned a studio hostname.');
      output.print('To deploy your Sanity Studio to our hosted Sanity.Studio service,');
      output.print('you will need one. Please enter the part you want to use.');

      studioHostname = yield prompt.single({
        type: 'input',
        filter: function filter(inp) {
          return inp.replace(/\.sanity\.studio$/i, '');
        },
        message: 'Studio hostname (<value>.sanity.studio):',
        validate: function validate(name) {
          return validateHostname(name, client);
        }
      });
    }

    // Always build the project, unless --no-build is passed
    const shouldBuild = flags.build;
    if (shouldBuild) {
      const buildStaticAssets = (0, _lazyRequire2.default)(require.resolve('../build/buildStaticAssets'));
      yield buildStaticAssets({ extOptions: {}, argsWithoutOptions: [] }, context);
    }

    // Ensure that the directory exists, is a directory and seems to have valid content
    spinner = output.spinner('Verifying local content').start();
    try {
      yield checkDir(sourceDir);
      spinner.succeed();
    } catch (err) {
      spinner.fail();
      throw err;
    }

    // Now create a tarball of the given directory
    const parentDir = _path2.default.dirname(sourceDir);
    const base = _path2.default.basename(sourceDir);
    const tarball = _tarFs2.default.pack(parentDir, { entries: [base] }).pipe(_zlib2.default.createGzip());

    spinner = output.spinner('Deploying to Sanity.Studio').start();
    try {
      const response = yield client.request({
        method: 'POST',
        url: '/deploy',
        body: tarball,
        maxRedirects: 0
      });

      spinner.succeed();

      // And let the user know we're done
      output.print(`\nSuccess! Studio deployed to ${chalk.cyan(response.location)}`);
    } catch (err) {
      spinner.fail();
      throw err;
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

function validateHostname(value, client) {
  const projectId = client.config().projectId;
  const uri = `/projects/${projectId}`;
  const studioHost = value || '';

  // Check that it matches allowed character range
  if (!/^[a-z0-9_-]+$/i.test(studioHost)) {
    return 'Hostname can contain only A-Z, 0-9, _ and -';
  }

  // Check that the hostname is not already taken
  return client.request({ uri: uri, method: 'PATCH', body: { studioHost: studioHost } }).then(() => true).catch(() => 'Hostname already taken');
}