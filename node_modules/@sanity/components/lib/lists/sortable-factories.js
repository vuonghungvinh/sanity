'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createSortableList = createSortableList;
exports.createSortableItem = createSortableItem;
exports.createDragHandle = createDragHandle;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactSortableHoc = require('react-sortable-hoc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function createSortableList(element) {

  // Delegate to SortableContainer from react-sortable-hoc
  var Sortable = (0, _reactSortableHoc.SortableContainer)(element);

  return function SortableList(props) {
    var onSort = props.onSort,
        movingItemClass = props.movingItemClass,
        distance = props.distance,
        useDragHandle = props.useDragHandle,
        lockToContainerEdges = props.lockToContainerEdges,
        axis = props.axis,
        lockAxis = props.lockAxis,
        transitionDuration = props.transitionDuration,
        helperClass = props.helperClass,
        pressDelay = props.pressDelay,
        pressThreshold = props.pressThreshold,
        shouldCancelStart = props.shouldCancelStart,
        onSortMove = props.onSortMove,
        useWindowAsScrollContainer = props.useWindowAsScrollContainer,
        hideSortableGhost = props.hideSortableGhost,
        lockOffset = props.lockOffset,
        getContainer = props.getContainer,
        getHelperDimensions = props.getHelperDimensions,
        rest = _objectWithoutProperties(props, ['onSort', 'movingItemClass', 'distance', 'useDragHandle', 'lockToContainerEdges', 'axis', 'lockAxis', 'transitionDuration', 'helperClass', 'pressDelay', 'pressThreshold', 'shouldCancelStart', 'onSortMove', 'useWindowAsScrollContainer', 'hideSortableGhost', 'lockOffset', 'getContainer', 'getHelperDimensions']);

    return _react2.default.createElement(Sortable, _extends({}, rest, {
      // onSortEnd={onSort}
      distance: distance,
      helperClass: movingItemClass,
      lockToContainerEdges: lockToContainerEdges,
      transitionDuration: transitionDuration,
      axis: axis,
      lockAxis: lockAxis,
      useDragHandle: useDragHandle
    }));
  };
}

function createSortableItem(element) {
  var Sortable = (0, _reactSortableHoc.SortableElement)(element);
  // Delegate to SortableElement from react-sortable-hoc
  return function SortableItem(props) {
    var collection = props.collection,
        disabled = props.disabled,
        index = props.index,
        rest = _objectWithoutProperties(props, ['collection', 'disabled', 'index']);

    return _react2.default.createElement(Sortable, _extends({ index: index }, rest));
  };
}

function createDragHandle(element) {
  return (0, _reactSortableHoc.SortableHandle)(element);
}