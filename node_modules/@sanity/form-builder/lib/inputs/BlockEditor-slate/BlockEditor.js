'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _uniqueId2 = require('lodash/uniqueId');

var _uniqueId3 = _interopRequireDefault(_uniqueId2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _slate = require('slate');

var _slateReact = require('slate-react');

var _fullscreen = require('part:@sanity/components/dialogs/fullscreen?');

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _scrollContainer = require('part:@sanity/components/utilities/scroll-container');

var _scrollContainer2 = _interopRequireDefault(_scrollContainer);

var _default = require('part:@sanity/components/formfields/default');

var _default2 = _interopRequireDefault(_default);

var _Toolbar = require('./toolbar/Toolbar');

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _createBlockEditorOperations = require('./createBlockEditorOperations');

var _createBlockEditorOperations2 = _interopRequireDefault(_createBlockEditorOperations);

var _prepareSlateForBlockEditor = require('./util/prepareSlateForBlockEditor');

var _prepareSlateForBlockEditor2 = _interopRequireDefault(_prepareSlateForBlockEditor);

var _initializeSlatePlugins = require('./util/initializeSlatePlugins');

var _initializeSlatePlugins2 = _interopRequireDefault(_initializeSlatePlugins);

var _BlockEditor = require('./styles/BlockEditor.css');

var _BlockEditor2 = _interopRequireDefault(_BlockEditor);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BlockEditor = function (_React$Component) {
  _inherits(BlockEditor, _React$Component);

  function BlockEditor(props, context) {
    _classCallCheck(this, BlockEditor);

    var _this = _possibleConstructorReturn(this, (BlockEditor.__proto__ || Object.getPrototypeOf(BlockEditor)).call(this, props, context));

    _this.state = {
      fullscreen: false,
      toolbarStyle: {}
    };
    _this._inputId = (0, _uniqueId3.default)('SlateBlockEditor');

    _this.handleNodePatch = function (event) {
      return _this.props.onNodePatch(event);
    };

    _this.handleInsertBlock = function (item) {
      if (item.options && item.options.inline) {
        _this.operations.insertInline(item);
        return;
      }
      _this.operations.insertBlock(item);
    };

    _this.handleOnClickMarkButton = function (mark) {
      _this.operations.toggleMark(mark);
    };

    _this.handleOnClickListFormattingButton = function (listItem, isActive) {
      _this.editor.focus();
      _this.operations.toggleListItem(listItem, isActive);
    };

    _this.handleAnnotationButtonClick = function (annotation) {
      _this.editor.focus();
      if (annotation.active) {
        var value = _this.props.value;

        var spans = value.inlines.filter(function (inline) {
          return inline.type == _constants.SLATE_SPAN_TYPE;
        });
        spans.forEach(function (span) {
          _this.operations.removeAnnotationFromSpan(span, annotation.type);
        });
        return;
      }
      _this.operations.createFormBuilderSpan(annotation.type);
    };

    _this.handleBlockStyleChange = function (selectedValue) {
      _this.operations.setBlockStyle(selectedValue.style.value);
      _this.refreshCSS();
    };

    _this.handleToggleFullscreen = function () {
      _this.setState(function (prevState) {
        return { fullscreen: !prevState.fullscreen };
      });
    };

    _this.refEditor = function (editor) {
      _this.editor = editor;
    };

    _this.refBlockDragMarker = function (marker) {
      _this.blockDragMarker = marker;
    };

    _this.refreshCSS = function () {
      var isWebkit = 'WebkitAppearance' in document.documentElement.style;
      if (!isWebkit) {
        return;
      }
      // Must be body because we have several scrollcontainers loosing state
      var resetNode = document.body;
      resetNode.style.display = 'none';
      // eslint-disable-next-line no-unused-expressions
      resetNode.offsetHeight; // Looks weird, but it actually has an effect!
      resetNode.style.display = '';
    };

    _this.handleEditorContainerClick = function () {
      _this.editor.focus();
    };

    _this.handleInputScroll = function (event) {
      // Prevents the parent container to scroll when user tries
      // to scroll to the top/bottom of the block editor with momentum scroll or
      // a speedy mouse wheel
      // This makes the block-editor more usable when scrolling inside it.

      /*
      Enable this when activeOnFocus is finished
       const el = this._inputContainer
      const scrollTop = el.scrollTop
      const scrollHeight = el.scrollHeight
      const height = el.clientHeight
       if (this.state.fullscreen) {
        return
      }
       if (event.nativeEvent.deltaY <= 0) {
        // scrolling up
        if (scrollTop <= 0) {
          event.preventDefault()
        }
      } else if (scrollTop + height >= scrollHeight) {
        // scrolling down
        event.preventDefault()
      }
      */
    };

    _this.setInputContainerElement = function (element) {
      _this._inputContainer = element;
    };

    _this.handleFullScreenScroll = function (event) {
      var threshold = 100;
      var scrollTop = event.target.scrollTop;
      if (scrollTop < threshold) {
        var ratio = scrollTop / threshold;
        _this.setState({
          toolbarStyle: {
            backgroundColor: 'rgba(255, 255, 255, ' + ratio * 0.95 + ')',
            boxShadow: '0 2px ' + 5 * ratio + 'px rgba(0, 0, 0, ' + ratio * 0.3 + ')'
          }
        });
      }
    };

    _this.handleFullScreenClose = function () {
      _this.setState({
        fullscreen: false
      });
    };

    var preparation = (0, _prepareSlateForBlockEditor2.default)(_this);
    _this.slateSchema = preparation.slateSchema;
    _this.textStyles = preparation.textStyles;
    _this.listItems = preparation.listItems;
    _this.annotationTypes = preparation.annotationTypes;
    _this.customBlocks = preparation.customBlocks;
    _this.operations = (0, _createBlockEditorOperations2.default)(_this);
    _this.slatePlugins = (0, _initializeSlatePlugins2.default)(_this);
    return _this;
  }

  _createClass(BlockEditor, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      window.addEventListener('keydown', this.handleKeyDown);
      // this._inputContainer.addEventListener('mousewheel', this.handleInputScroll)
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('keydown', this.handleKeyDown);
      // this._inputContainer.removeEventListener('mousewheel', this.handleInputScroll)
    }
  }, {
    key: 'hasAnnotationType',
    value: function hasAnnotationType(annotationType) {
      var value = this.props.value;

      var spans = value.inlines.filter(function (inline) {
        return inline.type == _constants.SLATE_SPAN_TYPE;
      });
      return spans.some(function (span) {
        var annotations = span.data.get('annotations') || {};
        return Object.keys(annotations).find(function (key) {
          return annotations[key]._type === annotationType.name;
        });
      });
    }
  }, {
    key: 'getActiveAnnotations',
    value: function getActiveAnnotations() {
      var _this2 = this;

      var value = this.props.value;
      var focusBlock = value.focusBlock;

      var disabled = value.inlines.some(function (inline) {
        return inline.type !== _constants.SLATE_SPAN_TYPE;
      }) || (focusBlock ? focusBlock.isVoid || focusBlock.text === '' : false);
      return this.annotationTypes.map(function (annotationType) {
        var active = _this2.hasAnnotationType(annotationType);
        return {
          active: active,
          type: annotationType,
          disabled: disabled
        };
      });
    }
  }, {
    key: 'hasStyle',
    value: function hasStyle(styleName) {
      var value = this.props.value;

      return value.blocks.some(function (block) {
        return block.data.get('style') === styleName;
      });
    }
  }, {
    key: 'getBlockStyles',
    value: function getBlockStyles() {
      var _this3 = this;

      function Preview(props) {
        return _react2.default.createElement(
          'span',
          null,
          props.children
        );
      }

      var items = this.textStyles.map(function (style, index) {
        return {
          key: 'blockFormat-' + index,
          style: style,
          preview: _this3.slateSchema.nodes.contentBlock({
            children: [_react2.default.createElement(
              Preview,
              {
                key: style.value,
                parent: { data: _slate.Data.create({ style: style.value }) }
              },
              style.title
            )]
          }),
          title: ' ' + style.title,
          active: _this3.hasStyle(style.value)
        };
      });
      var value = items.filter(function (item) {
        return item.active;
      });
      if (value.length === 0) {
        value = [{
          key: 'blockFormat-none',
          preview: null,
          type: null,
          title: 'No style',
          active: true
        }];
      }
      return {
        items: items,
        value: value
      };
    }
  }, {
    key: 'hasDecorator',
    value: function hasDecorator(decoratorName) {
      var value = this.props.value;

      return value.marks.some(function (mark) {
        return mark.type == decoratorName;
      });
    }
  }, {
    key: 'getActiveDecorators',
    value: function getActiveDecorators() {
      var _this4 = this;

      return Object.keys(this.slateSchema.marks).map(function (decorator) {
        return {
          type: decorator,
          active: _this4.hasDecorator(decorator)
        };
      });
    }
  }, {
    key: 'hasListItem',
    value: function hasListItem(listItem) {
      var value = this.props.value;

      return value.blocks.some(function (block) {
        return block.data.get('listItem') === listItem;
      });
    }
  }, {
    key: 'getListItems',
    value: function getListItems() {
      var _this5 = this;

      return this.listItems.map(function (item, index) {
        return {
          type: item.value,
          title: item.title,
          active: _this5.hasListItem(item.value)
        };
      });
    }
  }, {
    key: 'focus',
    value: function focus() {
      this.editor.focus();
    }

    // Webkit hack to force the browser to reapply CSS rules
    // This is needed to make ::before and ::after CSS rules work properly
    // under certain conditions (like the list counters for number lists)
    // http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes/3485654#3485654

  }, {
    key: 'showBlockDragMarker',
    value: function showBlockDragMarker(pos, node) {
      this.blockDragMarker.style.display = 'block';
      var editorDOMNode = _reactDom2.default.findDOMNode(this.editor);
      var editorRect = editorDOMNode.getBoundingClientRect();
      var elemRect = node.getBoundingClientRect();
      var topPos = elemRect.top - editorRect.top;
      var bottomPos = topPos + (elemRect.bottom - elemRect.top);
      if (pos == 'after') {
        this.blockDragMarker.style.top = parseInt(bottomPos, 0) + 'px';
      } else {
        this.blockDragMarker.style.top = parseInt(topPos, 0) + 'px';
      }
    }
  }, {
    key: 'hideBlockDragMarker',
    value: function hideBlockDragMarker() {
      this.blockDragMarker.style.display = 'none';
    }
  }, {
    key: 'renderBlockEditor',
    value: function renderBlockEditor() {
      var _props = this.props,
          value = _props.value,
          onChange = _props.onChange;
      var _state = this.state,
          fullscreen = _state.fullscreen,
          toolbarStyle = _state.toolbarStyle;


      return _react2.default.createElement(
        'div',
        {
          className: _BlockEditor2.default.root + ' ' + (fullscreen ? _BlockEditor2.default.fullscreen : '')
        },
        _react2.default.createElement(_Toolbar2.default, {
          className: _BlockEditor2.default.toolbar,
          onInsertBlock: this.handleInsertBlock,
          insertBlocks: this.customBlocks,
          onFullscreenEnable: this.handleToggleFullscreen,
          fullscreen: this.state.fullscreen,
          onMarkButtonClick: this.handleOnClickMarkButton,
          onAnnotationButtonClick: this.handleAnnotationButtonClick,
          onListButtonClick: this.handleOnClickListFormattingButton,
          onBlockStyleChange: this.handleBlockStyleChange,
          listItems: this.getListItems(),
          blockStyles: this.getBlockStyles(),
          annotations: this.getActiveAnnotations(),
          decorators: this.getActiveDecorators(),
          style: toolbarStyle
        }),
        _react2.default.createElement(
          'div',
          {
            className: _BlockEditor2.default.inputContainer,
            id: this._inputId,
            onClick: this.handleEditorContainerClick,
            ref: this.setInputContainerElement,
            onWheel: this.handleInputScroll
          },
          _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(_slateReact.Editor, {
              ref: this.refEditor,
              className: _BlockEditor2.default.input,
              onChange: onChange,
              placeholder: '',
              state: value,
              blockEditor: this,
              plugins: this.slatePlugins,
              schema: this.slateSchema
            }),
            _react2.default.createElement('div', {
              ref: this.refBlockDragMarker,
              style: { display: 'none' },
              className: _BlockEditor2.default.blockDragMarker
            })
          )
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this6 = this;

      var _props2 = this.props,
          type = _props2.type,
          level = _props2.level;
      var fullscreen = this.state.fullscreen;

      var blockEditor = this.renderBlockEditor();
      return _react2.default.createElement(
        _default2.default,
        {
          label: type.title,
          description: type.description,
          labelFor: this._inputId,
          level: level
        },
        _react2.default.createElement(
          'button',
          { tabIndex: 0, className: _BlockEditor2.default.focusSkipper, onClick: function onClick() {
              return _this6.focus();
            } },
          'Jump to editor'
        ),
        fullscreen ? _react2.default.createElement(
          _fullscreen2.default,
          { isOpen: true, onClose: this.handleFullScreenClose },
          _react2.default.createElement(
            _scrollContainer2.default,
            { className: _BlockEditor2.default.portal, onScroll: this.handleFullScreenScroll },
            blockEditor
          )
        ) : blockEditor
      );
    }
  }]);

  return BlockEditor;
}(_react2.default.Component);

BlockEditor.propTypes = {
  type: _propTypes2.default.any,
  level: _propTypes2.default.number,
  value: _propTypes2.default.instanceOf(_slate.State),
  onChange: _propTypes2.default.func,
  onNodePatch: _propTypes2.default.func
};
BlockEditor.defaultProps = {
  onChange: function onChange() {}
};
BlockEditor.contextTypes = {
  formBuilder: _propTypes2.default.object
};
exports.default = BlockEditor;