'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

exports.splitTextNodeIntoArraysOfCharacterBySpan = splitTextNodeIntoArraysOfCharacterBySpan;
exports.spanAccessorsToSlateNodes = spanAccessorsToSlateNodes;

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _slate = require('slate');

var _accessors = require('./accessors');

var _conversion = require('./conversion');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Given marks extracts the embedded special mark that tells us which span index that char
// is in according to the document structure in Sanity
function extractSpanIndexFromMarks(marks) {
  var indexMark = marks.find(function (mark) {
    return mark.get('type') == '__spanIdx';
  });
  if (indexMark) {
    return indexMark.get('data').get('index');
  }
  return null;
}

// Take a slate text node and split it into an array of arrays of characters splitting every time
// marks change so that each array corresponds to one consecutive "span" of characters with identical
// formatting.
function splitTextNodeIntoArraysOfCharacterBySpan(textNode) {
  var result = textNode.characters.reduce(function (acc, char, idx) {
    var prevChar = idx > 0 && textNode.characters.get(idx - 1);
    if (prevChar && _immutable2.default.is(prevChar.marks, char.marks)) {
      acc[acc.length - 1].push(char);
    } else {
      // Find the span index of the next character and insert empty spans if need be to
      // make that next char still be in a span of that index. This is to ensure that the document structure
      // stays as described in the source Sanity document.
      var nextSpanIndex = extractSpanIndexFromMarks(char.marks) || 0;
      while (acc.length < nextSpanIndex) {
        acc.push([]);
      }
      acc.push([char]);
    }
    return acc;
  }, []);
  return result;
}

// Take a number of consecutive sanity spans and join them together into an immutable character array for use with slate
function consecutiveSanitySpansToSlateText(key, spans, firstIndex) {
  var index = firstIndex;
  var chars = (0, _flatten3.default)(spans.map(function (span) {
    // Convert the marks from the span and add the book-keeping tag to keep track of which span each character belongs to
    var marks = (0, _conversion.sanityMarksToSlate)(span.marks).add(_slate.Mark.create({
      type: '__spanIdx',
      data: { index: index }
    }));
    index += 1;
    return span.content.split('').map(function (char) {
      return { text: char, marks: marks };
    });
  }));
  return _slate.Text.create({
    key: key,
    characters: _immutable2.default.List(chars.map(function (_ref) {
      var text = _ref.text,
          marks = _ref.marks;
      return _slate.Character.create({ text: text, marks: marks });
    }))
  });
}

// Takes an array of span accessors and converts them into the corresponding list of immutable slate spans
function spanAccessorsToSlateNodes(spans) {
  var joined = _immutable2.default.List();
  var i = 0;
  while (i < spans.length) {
    var span = spans[i];
    if (span instanceof _accessors.TextSpanAccessor) {
      var firstIndex = i;
      // consume until we get something else
      var next = i;
      while (next < spans.length && spans[next] instanceof _accessors.TextSpanAccessor) {
        // eslint-disable-line max-depth
        next++;
      }
      joined = joined.push(consecutiveSanitySpansToSlateText(span.key, spans.slice(i, next), firstIndex));
      i = next;
    }
  }

  return joined;
}