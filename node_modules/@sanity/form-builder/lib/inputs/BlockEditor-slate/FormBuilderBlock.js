'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _offsetKey = require('slate-react/lib/utils/offset-key');

var _offsetKey2 = _interopRequireDefault(_offsetKey);

var _setTransferData = require('slate-react/lib/utils/set-transfer-data');

var _setTransferData2 = _interopRequireDefault(_setTransferData);

var _transferTypes = require('slate-react/lib/constants/transfer-types');

var _transferTypes2 = _interopRequireDefault(_transferTypes);

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _slateReact = require('slate-react');

var _ItemForm = require('./ItemForm');

var _ItemForm2 = _interopRequireDefault(_ItemForm);

var _fullscreen = require('part:@sanity/components/dialogs/fullscreen');

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _popover = require('part:@sanity/components/edititem/popover');

var _popover2 = _interopRequireDefault(_popover);

var _fold = require('part:@sanity/components/edititem/fold');

var _fold2 = _interopRequireDefault(_fold);

var _Preview = require('../../Preview');

var _Preview2 = _interopRequireDefault(_Preview);

var _FormBuilderBlock = require('./styles/FormBuilderBlock.css');

var _FormBuilderBlock2 = _interopRequireDefault(_FormBuilderBlock);

var _createRange = require('./util/createRange');

var _createRange2 = _interopRequireDefault(_createRange);

var _simplePatch = require('../../simplePatch');

var _resolveTypeName = require('../../utils/resolveTypeName');

var _InvalidValue = require('../InvalidValue');

var _InvalidValue2 = _interopRequireDefault(_InvalidValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FormBuilderBlock = function (_React$Component) {
  _inherits(FormBuilderBlock, _React$Component);

  function FormBuilderBlock() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, FormBuilderBlock);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FormBuilderBlock.__proto__ || Object.getPrototypeOf(FormBuilderBlock)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isSelected: false,
      isEditing: false,
      isDragging: false
    }, _this._dropTarget = null, _this._editorNode = null, _this.handleChange = function (event) {
      var _this$props = _this.props,
          onPatch = _this$props.onPatch,
          node = _this$props.node;

      onPatch(event.prefixAll(node.key));
    }, _this.handleInvalidValueChange = function (event) {
      var _this$props2 = _this.props,
          onPatch = _this$props2.onPatch,
          node = _this$props2.node;

      onPatch(event.prefixAll(node.key));
    }, _this.handleDragStart = function (event) {
      var editor = _this.props.editor;

      _this._editorNode = _reactDom2.default.findDOMNode(editor);

      _this.setState({ isDragging: true });
      _this.addDragHandlers();

      var element = _reactDom2.default.findDOMNode(_this.previewContainer);
      var encoded = _slateBase64Serializer2.default.serializeNode(_this.props.node, { preserveKeys: true });
      (0, _setTransferData2.default)(event.dataTransfer, _transferTypes2.default.NODE, encoded);
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setDragImage(element, element.clientWidth / 2, -10);
    }, _this.handleSelectionChange = function (event) {
      var selection = document.getSelection();
      var isSelected = selection.containsNode && selection.containsNode(_this.formBuilderBlock);
      _this.setState({ isSelected: isSelected });
    }, _this.handleDragLeave = function (event) {
      _this.hideBlockDragMarker();
      if (event.target === _this._editorNode) {
        _this.resetDropTarget();
      }
    }, _this.handleDragOverOtherNode = function (event) {

      if (!_this.state.isDragging) {
        return;
      }

      var targetDOMNode = event.target;

      // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself
      if (targetDOMNode === _this._editorNode) {
        return;
      }

      var offsetKey = _offsetKey2.default.findKey(targetDOMNode, 0);
      if (!offsetKey) {
        return;
      }
      var key = offsetKey.key;
      var editor = _this.props.editor;

      var state = editor.getState();
      var document = state.document;

      var range = (0, _createRange2.default)(event);

      if (range === null) {
        return;
      }

      var rangeIsAtStart = range.rangeIsAtStart,
          rangeOffset = range.rangeOffset;


      var node = document.getClosestBlock(key);

      if (!node) {
        _this.resetDropTarget();
        return;
      }

      var domNode = (0, _slateReact.findDOMNode)(node);
      if (rangeIsAtStart) {
        _this.showBlockDragMarker('before', domNode);
      } else {
        _this.showBlockDragMarker('after', domNode);
      }
      _this._dropTarget = { node: node, isAtStart: rangeIsAtStart, offset: rangeOffset };
    }, _this.handleDragEnd = function (event) {
      _this.setState({ isDragging: false });
      _this.removeDragHandlers();

      var _this$props3 = _this.props,
          editor = _this$props3.editor,
          node = _this$props3.node;

      var state = editor.getState();

      var target = _this._dropTarget;

      // Return if this is our node
      if (!target || target.node === node) {
        _this.resetDropTarget();
        return;
      }

      var nextChange = state.change().removeNodeByKey(node.key);
      nextChange = nextChange[target.isAtStart ? 'collapseToStartOf' : 'collapseToEndOf'](target.node).insertBlock(node).collapseToEndOf(node).focus();

      editor.onChange(nextChange);

      _this.resetDropTarget();
    }, _this.handleCancelEvent = function (event) {
      event.preventDefault();
    }, _this.handleToggleEdit = function () {
      _this.setState({ isEditing: true });
    }, _this.handleClose = function () {
      _this.setState({ isEditing: false });
    }, _this.refFormBuilderBlock = function (formBuilderBlock) {
      _this.formBuilderBlock = formBuilderBlock;
    }, _this.refPreview = function (previewContainer) {
      _this.previewContainer = previewContainer;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(FormBuilderBlock, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.addSelectionHandler();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeSelectionHandler();
    }
  }, {
    key: 'addSelectionHandler',
    value: function addSelectionHandler() {
      document.addEventListener('selectionchange', this.handleSelectionChange);
    }
  }, {
    key: 'removeSelectionHandler',
    value: function removeSelectionHandler() {
      document.removeEventListener('selectionchange', this.handleSelectionChange);
    }
  }, {
    key: 'addDragHandlers',
    value: function addDragHandlers() {
      this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);
      this._editorNode.addEventListener('dragleave', this.handleDragLeave);
    }
  }, {
    key: 'removeDragHandlers',
    value: function removeDragHandlers() {
      this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);
      this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
    }

    // Remove the drop target if we leave the editors nodes

  }, {
    key: 'resetDropTarget',
    value: function resetDropTarget() {
      this._dropTarget = null;
      this.hideBlockDragMarker();
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.props.node.data.get('value');
    }
  }, {
    key: 'getMemberTypeOf',
    value: function getMemberTypeOf(value) {
      var typeName = (0, _resolveTypeName.resolveTypeName)(value);
      return this.props.type.of.find(function (memberType) {
        return memberType.name === typeName;
      });
    }
  }, {
    key: 'renderPreview',
    value: function renderPreview() {
      var value = this.getValue();
      var memberType = this.getMemberTypeOf(value);
      if (!memberType) {
        var validMemberTypes = this.props.type.of.map(function (type) {
          return type.name;
        });
        var actualType = (0, _resolveTypeName.resolveTypeName)(value);
        return _react2.default.createElement(_InvalidValue2.default, {
          validTypes: validMemberTypes,
          actualType: actualType,
          value: value,
          onChange: this.handleInvalidValueChange
        });
      }
      return _react2.default.createElement(_Preview2.default, {
        type: memberType,
        value: this.getValue(),
        layout: 'block'
      });
    }
  }, {
    key: 'renderInput',
    value: function renderInput() {
      var value = this.getValue();
      var memberType = this.getMemberTypeOf(value);

      var fieldsQty = (memberType && memberType.fields || []).length;

      var editModalLayout = (0, _get3.default)(this, 'props.type.options.editModal');

      // Choose editModal based on number of fields
      if (!editModalLayout) {
        if (fieldsQty < 3) {
          editModalLayout = 'popover';
        } else {
          editModalLayout = 'fullscreen';
        }
      }

      if (editModalLayout === 'fullscreen') {
        return _react2.default.createElement(
          _fullscreen2.default,
          {
            isOpen: true,
            title: this.props.node.title,
            onClose: this.handleClose
          },
          _react2.default.createElement(_ItemForm2.default, {
            onDrop: this.handleCancelEvent,
            type: memberType,
            level: 0,
            value: this.getValue(),
            onChange: this.handleChange
          })
        );
      }

      if (editModalLayout === 'fold') {
        return _react2.default.createElement(
          'div',
          { className: _FormBuilderBlock2.default.editBlockContainerFold },
          _react2.default.createElement(
            _fold2.default,
            {
              isOpen: true,
              title: this.props.node.title,
              onClose: this.handleClose
            },
            _react2.default.createElement(_ItemForm2.default, {
              onDrop: this.handleCancelEvent,
              type: memberType,
              level: 0,
              value: this.getValue(),
              onChange: this.handleChange
            })
          )
        );
      }

      // default
      return _react2.default.createElement(
        'div',
        { className: _FormBuilderBlock2.default.editBlockContainerPopOver },
        _react2.default.createElement(
          _popover2.default,
          {
            isOpen: true,
            title: this.props.node.title,
            onClose: this.handleClose
          },
          _react2.default.createElement(_ItemForm2.default, {
            onDrop: this.handleCancelEvent,
            type: memberType,
            level: 0,
            value: this.getValue(),
            onChange: this.handleChange
          })
        )
      );
    }
  }, {
    key: 'showBlockDragMarker',
    value: function showBlockDragMarker(pos, node) {
      var editor = this.props.editor;

      editor.props.blockEditor.showBlockDragMarker(pos, node);
    }
  }, {
    key: 'hideBlockDragMarker',
    value: function hideBlockDragMarker() {
      var editor = this.props.editor;

      editor.props.blockEditor.hideBlockDragMarker();
    }
  }, {
    key: 'render',
    value: function render() {
      var isEditing = this.state.isEditing;
      var _props = this.props,
          attributes = _props.attributes,
          node = _props.node,
          editor = _props.editor;

      var isFocused = editor.props.blockEditor.props.value.selection.hasFocusIn(node);

      var className = void 0;
      if (isFocused && !this.state.isSelected) {
        className = _FormBuilderBlock2.default.focused;
      } else if (this.state.isSelected) {
        className = _FormBuilderBlock2.default.selected;
      } else {
        className = _FormBuilderBlock2.default.root;
      }

      return _react2.default.createElement(
        'div',
        _extends({}, attributes, {
          onDragStart: this.handleDragStart,
          onDragEnd: this.handleDragEnd,
          onDragEnter: this.handleCancelEvent,
          onDragLeave: this.handleCancelEvent,
          onDrop: this.handleCancelEvent,
          draggable: true,
          onClick: this.handleToggleEdit,
          ref: this.refFormBuilderBlock,
          className: className
        }),
        _react2.default.createElement(
          'span',
          {
            ref: this.refPreview,
            className: _FormBuilderBlock2.default.previewContainer
          },
          this.renderPreview()
        ),
        isEditing && this.renderInput()
      );
    }
  }]);

  return FormBuilderBlock;
}(_react2.default.Component);

FormBuilderBlock.propTypes = {
  // Note: type refers to the array type, not the value type
  type: _propTypes2.default.object,
  node: _propTypes2.default.object,
  editor: _propTypes2.default.object,
  state: _propTypes2.default.object,
  attributes: _propTypes2.default.object,
  onPatch: _propTypes2.default.func
};
exports.default = FormBuilderBlock;