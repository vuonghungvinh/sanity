'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// Preview components of different text types


exports.default = prepareSlateForBlockEditor;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _slate = require('slate');

var _createBlockNode = require('../createBlockNode');

var _createBlockNode2 = _interopRequireDefault(_createBlockNode);

var _createInlineNode = require('../createInlineNode');

var _createInlineNode2 = _interopRequireDefault(_createInlineNode);

var _createSpanNode = require('../createSpanNode');

var _createSpanNode2 = _interopRequireDefault(_createSpanNode);

var _mapToObject = require('./mapToObject');

var _mapToObject2 = _interopRequireDefault(_mapToObject);

var _randomKey = require('../util/randomKey');

var _randomKey2 = _interopRequireDefault(_randomKey);

var _spanHelpers = require('./spanHelpers');

var _constants = require('../constants');

var _Blockquote = require('../preview/Blockquote');

var _Blockquote2 = _interopRequireDefault(_Blockquote);

var _Header = require('../preview/Header');

var _Header2 = _interopRequireDefault(_Header);

var _ListItem = require('../preview/ListItem');

var _ListItem2 = _interopRequireDefault(_ListItem);

var _Decorator = require('../preview/Decorator');

var _Decorator2 = _interopRequireDefault(_Decorator);

var _Normal = require('../preview/Normal');

var _Normal2 = _interopRequireDefault(_Normal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Set our own key generator for Slate
var keyGenerator = function keyGenerator() {
  return (0, _randomKey2.default)(12);
};
(0, _slate.setKeyGenerator)(keyGenerator);

// When the slate-fields are rendered in the editor, their node data is stored in a parent container component.
// In order to use the node data as props inside our components, we have to dereference them here first (see list and header keys)
var slateTypeComponentMapping = {
  normal: _Normal2.default,
  h1: function h1(props) {
    return _react2.default.createElement(_Header2.default, _extends({ level: 1 }, props));
  },
  h2: function h2(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 2 }, props));
  },
  h3: function h3(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 3 }, props));
  },
  h4: function h4(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 4 }, props));
  },
  h5: function h5(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 5 }, props));
  },
  h6: function h6(props) {
    // eslint-disable-line react/no-multi-comp
    return _react2.default.createElement(_Header2.default, _extends({ level: 6 }, props));
  },
  listItem: function listItem(props) {
    // eslint-disable-line react/no-multi-comp
    // eslint-disable-next-line react/prop-types
    var listItem = props.children[0] && props.children[0].props.parent.data.get('listItem');
    // eslint-disable-next-line react/prop-types
    var level = props.children[0] && props.children[0].props.parent.data.get('level');
    // eslint-disable-next-line react/prop-types
    var style = props.children[0] && props.children[0].props.parent.data.get('style') || _constants.BLOCK_DEFAULT_STYLE;
    var contentComponent = slateTypeComponentMapping[style];
    return _react2.default.createElement(_ListItem2.default, _extends({ contentComponent: contentComponent, level: level, listItem: listItem }, props));
  },

  blockquote: _Blockquote2.default

  // Create a contentBlock component
};function createContentBlock(props) {
  var component = null;
  var style = props.children[0] && props.children[0].props.parent.data.get('style');
  var isListItem = props.children[0] && props.children[0].props.parent.data.get('listItem');
  if (isListItem) {
    component = slateTypeComponentMapping.listItem;
  } else {
    component = slateTypeComponentMapping[style];
  }
  if (!component) {
    // eslint-disable-next-line no-console
    console.warn('No mapping for style \'' + style + '\' exists, using \'normal\'');
    component = slateTypeComponentMapping.normal;
  }
  return component(props);
}

function prepareSlateForBlockEditor(blockEditor) {

  var type = blockEditor.props.type;
  var blockType = type.of.find(function (ofType) {
    return ofType.name === 'block';
  });
  if (!blockType) {
    throw new Error("'block' type is not defined in the schema (required).");
  }

  var styleField = blockType.fields.find(function (btField) {
    return btField.name === 'style';
  });
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }

  var textStyles = styleField.type.options.list && styleField.type.options.list.filter(function (style) {
    return style.value;
  });
  if (!textStyles || textStyles.length === 0) {
    throw new Error('The style fields need at least one style ' + "defined. I.e: {title: 'Normal', value: 'normal'}.");
  }

  var listField = blockType.fields.find(function (btField) {
    return btField.name === 'list';
  });
  var listItems = [];
  if (listField) {
    listItems = listField.type.options.list && listField.type.options.list.filter(function (listStyle) {
      return listStyle.value;
    });
  }

  var memberTypesExceptBlock = type.of.filter(function (ofType) {
    return ofType.name !== 'block';
  });
  var spanType = (0, _spanHelpers.getSpanType)(type);
  var allowedDecorators = spanType.decorators.map(function (decorator) {
    return decorator.value;
  });

  var FormBuilderBlock = (0, _createBlockNode2.default)(type, blockEditor.handleNodePatch);
  var FormBuilderInline = (0, _createInlineNode2.default)(type, blockEditor.handleNodePatch);

  var slateSchema = {
    nodes: _extends({}, (0, _mapToObject2.default)(memberTypesExceptBlock, function (ofType) {
      return [ofType.name, ofType.options && ofType.options.inline ? FormBuilderInline : FormBuilderBlock];
    }), {
      __unknown: FormBuilderBlock,
      span: (0, _createSpanNode2.default)(spanType),
      contentBlock: createContentBlock
    }),
    marks: (0, _mapToObject2.default)(allowedDecorators, function (decorator) {
      return [decorator, _Decorator2.default];
    }),
    rules: [
    // Rule to insert a default block when document is empty,
    // or only contains one empty contentBlock
    {
      match: function match(node) {
        return node.kind === 'document';
      },
      validate: function validate(document) {
        return document.nodes.size === 0 || document.nodes.size === 1 && document.nodes.first().type === _constants.SLATE_DEFAULT_BLOCK.type && document.nodes.first().text === '' && document.nodes.first().data.get('style') !== _constants.BLOCK_DEFAULT_STYLE ? document : null;
      },
      normalize: function normalize(change, document) {
        change.deselect();
        var hasEmptySingleContentBlock = document.nodes.size === 1;
        change.insertNodeByKey(document.key, 0, _slate.Block.create(_constants.SLATE_DEFAULT_BLOCK));
        if (hasEmptySingleContentBlock) {
          change.removeNodeByKey(document.nodes.first().key);
        }
        return change.collapseToStartOf(change.state.document.nodes.first()).focus();
      }
    },
    // Rule to ensure that every non-void block has a style
    {
      match: function match(node) {
        if (node.kind === 'block' && !node.isVoid) {
          return node;
        }
        return undefined;
      },
      validate: function validate(block) {
        return block.data.get('style') === undefined ? block : null;
      },
      normalize: function normalize(change, block) {
        var data = _extends({}, block.data.toObject(), { style: _constants.BLOCK_DEFAULT_STYLE });
        return change.setNodeByKey(block.key, { data: data });
      }
    },
    // Rule to ensure that annotation _key's within a block is unique
    // Duplication can happen when copy/pasting annotation spans within the same block
    {
      match: function match(node) {
        // contentBlock with annotations
        return node.kind === 'block' && node.type === 'contentBlock' && node.filterDescendants(function (desc) {
          var annotations = desc.data && desc.data.get('annotations');
          return annotations && Object.keys(annotations).length;
        }).size;
      },

      validate: function validate(contentBlock) {
        // return the last occurence of nodes with annotations that has the same _key
        var duplicateKeyNodes = contentBlock.filterDescendants(function (desc) {
          return desc.data && desc.data.get('annotations');
        }).toArray().map(function (aNode) {
          var annotations = aNode.data.get('annotations');
          return Object.keys(annotations).map(function (name) {
            return annotations[name]._key;
          });
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []).filter(function (key, i, keys) {
          return keys.lastIndexOf(key) !== i;
        });
        if (duplicateKeyNodes.length) {
          return duplicateKeyNodes.map(function (key) {
            return {
              dupKey: key,
              dupNode: contentBlock.filterDescendants(function (desc) {
                var annotations = desc.data && desc.data.get('annotations');
                return annotations && Object.keys(annotations).find(function (name) {
                  return annotations[name]._key === key;
                });
              }).toArray().slice(-1)[0] // Last occurence
            };
          });
        }
        return null;
      },
      normalize: function normalize(change, node, dupNodes) {
        dupNodes.forEach(function (dup) {
          var dupKey = dup.dupKey,
              dupNode = dup.dupNode;

          var annotations = _extends({}, dupNode.data.get('annotations'));
          var newAnnotations = {};
          Object.keys(annotations).forEach(function (name) {
            newAnnotations[name] = _extends({}, annotations[name]);
            if (annotations[name]._key === dupKey) {
              newAnnotations[name]._key = (0, _randomKey2.default)(12);
            }
          });
          var data = _extends({}, dupNode.data.toObject(), { annotations: newAnnotations });
          change.setNodeByKey(dupNode.key, { data: data });
        });
        return change;
      }
    }]
  };
  return {
    listItems: listItems,
    textStyles: textStyles,
    annotationTypes: spanType.annotations,
    decorators: spanType.decorators,
    customBlocks: memberTypesExceptBlock,
    slateSchema: slateSchema
  };
}