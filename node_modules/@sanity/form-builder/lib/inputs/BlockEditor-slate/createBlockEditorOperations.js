'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createBlockEditorOperations;

var _constants = require('./constants');

var _createProtoValue = require('./createProtoValue');

var _randomKey = require('./util/randomKey');

var _randomKey2 = _interopRequireDefault(_randomKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createBlockEditorOperations(blockEditor) {

  function onChange(change) {
    return blockEditor.props.onChange(change);
  }

  function getState() {
    // Work on absolutely current state of the slate editor
    // blockEditor.props.value (state) could potentially be out of sync
    return blockEditor.editor.getState();
  }

  return {
    createFormBuilderSpan: function createFormBuilderSpan(annotationType) {
      var state = getState();
      var change = void 0;

      if (state.isExpanded) {
        change = state.change();
      } else {
        change = this.expandToFocusedWord(state.change());
        if (!change) {
          return null;
        }
      }
      var key = (0, _randomKey2.default)(12);
      var span = {
        isVoid: false,
        type: _constants.SLATE_SPAN_TYPE,
        kind: 'inline',
        data: undefined,
        key: key
      };
      change.unwrapInline(_constants.SLATE_SPAN_TYPE).wrapInline(span);

      var currentSpan = blockEditor.props.value.inlines.filter(function (inline) {
        return inline.key === key;
      }).first();

      var data = {
        annotations: currentSpan ? currentSpan.data.get('annotations') || {} : {},
        focusedAnnotationName: annotationType.name
      };
      data.annotations[annotationType.name] = (0, _createProtoValue.createProtoValue)(annotationType, key);

      return onChange(change.setInline({ data: data }));
    },
    removeAnnotationFromSpan: function removeAnnotationFromSpan(spanNode, annotationType) {
      var state = getState();
      var annotations = spanNode.data.get('annotations');
      if (!annotations) {
        return;
      }
      // Remove the whole span if this annotation is the only one left
      if (Object.keys(annotations).length === 1 && annotations[annotationType.name]) {
        this.removeSpan(spanNode);
        return;
      }
      // If several annotations, remove only this one and leave the node intact
      Object.keys(annotations).forEach(function (name) {
        if (annotations[name]._type === annotationType.name) {
          delete annotations[name];
        }
      });
      var data = _extends({}, spanNode.data.toObject(), {
        focusedAnnotationName: undefined,
        annotations: annotations
      });
      var nextChange = state.change().setNodeByKey(spanNode.key, { data: data });

      onChange(nextChange);
    },
    removeSpan: function removeSpan(spanNode) {
      var state = getState();
      var change = void 0;
      if (Array.isArray(spanNode)) {
        change = state.change();
        spanNode.forEach(function (node) {
          change = change.unwrapInlineByKey(node.key);
        });
        change = change.focus();
      } else if (spanNode) {
        change = state.change().unwrapInlineByKey(spanNode.key).focus();
      } else {
        // Apply on current selection
        change = state.change().unwrapInline(_constants.SLATE_SPAN_TYPE).focus();
      }
      onChange(change);
    },
    toggleListItem: function toggleListItem(listItemName, isActive) {
      var state = getState();
      var normalBlock = _constants.SLATE_DEFAULT_BLOCK;
      var listItemBlock = {
        type: 'contentBlock',
        data: { listItem: listItemName, style: _constants.BLOCK_DEFAULT_STYLE, level: 1 }
      };
      var change = state.change();

      if (isActive) {
        change.setBlock(normalBlock);
      } else {
        change.setBlock(listItemBlock);
      }
      onChange(change.focus());
    },
    setBlockStyle: function setBlockStyle(styleName) {
      var state = getState();
      var selection = state.selection,
          startBlock = state.startBlock,
          endBlock = state.endBlock;

      var change = state.change();

      // If a single block is selected partially, split block conditionally
      // (selection in start, middle or end of text)
      if (startBlock === endBlock && selection.isExpanded && !(selection.hasStartAtStartOf(startBlock) && selection.hasEndAtEndOf(startBlock))) {
        var hasTextBefore = !selection.hasStartAtStartOf(startBlock);
        var hasTextAfter = !selection.hasEndAtEndOf(startBlock);
        if (hasTextAfter) {
          var extendForward = selection.isForward ? selection.focusOffset - selection.anchorOffset : selection.anchorOffset - selection.focusOffset;
          change.collapseToStart().splitBlock().moveForward().extendForward(extendForward).collapseToEnd().splitBlock().collapseToStartOfPreviousText();
        } else if (hasTextBefore) {
          change.collapseToStart().splitBlock().moveForward();
        } else {
          change.collapseToEnd().splitBlock().select(selection);
        }
      }
      change.focus();

      // Do the actual style transform, only acting on type contentBlock
      state.blocks.forEach(function (blk) {
        var newData = _extends({}, blk.data.toObject(), { style: styleName });
        if (blk.type === 'contentBlock') {
          change = change.setNodeByKey(blk.key, { data: newData });
        }
      });
      onChange(change.focus());
    },
    insertBlock: function insertBlock(type) {
      var state = getState();
      var key = (0, _randomKey2.default)(12);
      var block = {
        type: type.name,
        isVoid: true,
        key: key,
        data: {
          value: (0, _createProtoValue.createProtoValue)(type, key)
        }
      };
      onChange(state.change().insertBlock(block));
    },
    insertInline: function insertInline(type) {
      var state = getState();
      var key = (0, _randomKey2.default)(12);
      var props = {
        type: type.name,
        isVoid: true,
        key: key,
        data: {
          value: (0, _createProtoValue.createProtoValue)(type, key)
        }
      };

      onChange(state.change().insertInline(props));
    },
    toggleMark: function toggleMark(mark) {
      onChange(getState().change().toggleMark(mark.type).focus());
    },
    expandToFocusedWord: function expandToFocusedWord(change) {
      var _change$state = change.state,
          focusText = _change$state.focusText,
          focusOffset = _change$state.focusOffset;

      var charsBefore = focusText.characters.slice(0, focusOffset);
      var charsAfter = focusText.characters.slice(focusOffset, -1);
      var isEmpty = function isEmpty(obj) {
        return obj.get('text').match(/\s/g);
      };
      var whiteSpaceBeforeIndex = charsBefore.reverse().findIndex(function (obj) {
        return isEmpty(obj);
      });

      var newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.size - whiteSpaceBeforeIndex : -1;

      var whiteSpaceAfterIndex = charsAfter.findIndex(function (obj) {
        return isEmpty(obj);
      });
      var newEndOffset = charsBefore.size + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.size + 1);

      // Not near any word, abort
      if (newStartOffset === newEndOffset) {
        return null;
      }
      // Select and highlight current word
      return change.moveOffsetsTo(newStartOffset, newEndOffset).focus();
    },
    expandToNode: function expandToNode(node) {
      return getState().change().moveToRangeOf(node).focus();
    }
  };
}