'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParagraphAccessor = exports.SpansAccessor = exports.TextSpanAccessor = exports.NodeAccessor = undefined;

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mutator = require('@sanity/mutator');

var _randomKey = require('../Array/randomKey');

var _randomKey2 = _interopRequireDefault(_randomKey);

var _docUtils = require('./docUtils');

var _conversion = require('./conversion');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// This accessor is meant to access nodes that are not common text nodes, but alas it has not yet been
// implemented.
var NodeAccessor = exports.NodeAccessor = function () {
  function NodeAccessor(node) {
    _classCallCheck(this, NodeAccessor);

    this.node = node;
  }

  _createClass(NodeAccessor, [{
    key: 'containerType',
    value: function containerType() {
      return 'object';
    }
  }, {
    key: 'getAttribute',
    value: function getAttribute(attr) {
      // TODO
      return new _mutator.ImmutableAccessor(this.node);
    }
  }, {
    key: 'setAttribute',
    value: function setAttribute(key, value) {
      return new NodeAccessor(this.node.setIn([key], value));
    }
  }, {
    key: 'setAttributeAccessor',
    value: function setAttributeAccessor(key, accessor) {
      return this;
    }
  }, {
    key: 'hasAttribute',
    value: function hasAttribute(key) {
      return key === 'nodes';
    }
  }]);

  return NodeAccessor;
}();

// Represents a span of characters with identical marks. In Sanity terms this accessor corresponds to a single
// 'textspan', in Slate terms it corresponds to a consecutive array of characters of identical marks within a
// text node.


var TextSpanAccessor = exports.TextSpanAccessor = function () {
  _createClass(TextSpanAccessor, [{
    key: 'serialize',
    value: function serialize() {
      var result = {
        _type: 'textspan',
        content: this.content
      };
      if (this.marks.length > 0) {
        result.marks = this.marks;
      }
      return result;
    }
  }], [{
    key: 'createFromTextNode',
    value: function createFromTextNode(key, textSpan) {
      var content = textSpan.map(function (char) {
        return char.get('text');
      }).join('');
      var marks = textSpan.length > 0 ? (0, _conversion.slateMarksToSanity)(textSpan[0].get('marks')) : [];
      return new TextSpanAccessor({ key: key, content: content, marks: marks });
    }
  }]);

  function TextSpanAccessor(_ref) {
    var key = _ref.key,
        content = _ref.content,
        marks = _ref.marks;

    _classCallCheck(this, TextSpanAccessor);

    this.key = key;
    this.content = content;
    this.marks = marks;
  }

  _createClass(TextSpanAccessor, [{
    key: 'containerType',
    value: function containerType() {
      return 'object';
    }
  }, {
    key: 'getAttribute',
    value: function getAttribute(attr) {
      if (attr === '_type') {
        return new _mutator.ImmutableAccessor('textspan');
      }
      if (attr === 'content') {
        return new _mutator.ImmutableAccessor(this.content);
      }
      if (attr === 'marks') {
        return new _mutator.ImmutableAccessor(this.marks);
      }
      throw new Error('Unknown key "' + attr + '"');
    }
  }, {
    key: 'setAttribute',
    value: function setAttribute(attr, value) {
      if (attr === 'content') {
        return new TextSpanAccessor({ content: value, marks: this.marks, key: this.key });
      }
      if (attr === 'marks') {
        return new TextSpanAccessor({ content: this.content, marks: value, key: this.key });
      }
      throw new Error('Unable to set attribute "' + attr + '" of type textspan');
    }
  }, {
    key: 'setAttributeAccessor',
    value: function setAttributeAccessor(attr, value) {
      if (attr === 'content') {
        return new TextSpanAccessor({ content: value.get(), marks: this.mark, key: this.keys });
      }
      if (attr === 'marks') {
        return new TextSpanAccessor({ content: this.content, marks: value.get(), key: this.key });
      }
      throw new Error('Unable to set attribute "' + attr + '" of type textspan');
    }
  }, {
    key: 'hasAttribute',
    value: function hasAttribute(attr) {
      return attr === 'content' || attr === 'marks' || attr === '_type';
    }
  }]);

  return TextSpanAccessor;
}();

// Represents the spans of a paragraph. The impedance mismatch between the slate native representation and the sanity representation
// is problematic here as a single text node with different stylings, i.e. something like "this is <em>important</em>" are represented
// as individual textspan nodes i sanity, while they are one character array within slate. The SpanAccessor solves this problem by converting
// the entire nodes array into an array of accessors immediately upon creation.
//
// TODO: Sine accessors often are only bypassed very quickly while patching something deep inside them, this would probably do well to
// rather work lazily, only converting exactly what is being asked for to accessors. But this is complex and is left as an exercise for the
// future.

var SpansAccessor = exports.SpansAccessor = function () {
  _createClass(SpansAccessor, [{
    key: 'serialize',
    value: function serialize() {
      var length = this.length();
      var result = [];
      for (var i = 0; i < length; i++) {
        result.push(this.getIndex(i));
      }
      return result;
    }

    // In order to maintain compatibility with the Sanity model we may accrue some inefficiencies in the encoding during editing of a
    // block. This method generates an optional clean up patch which would be good to apply every now and then

  }, {
    key: 'generateCleanUpPatch',
    value: function generateCleanUpPatch() {
      var patches = [];
      // Then, let's find all empty spans
      var indiciesToDelete = [];
      var spansAfterPruning = [];
      this.spans.forEach(function (span, index) {
        if (span.getAttribute('_type').get() == 'textspan') {
          if (span.content.length == 0) {
            indiciesToDelete.push(index);
            return;
          }
        }
        spansAfterPruning.push(span);
      });
      // Generate a patch deleting all these spans
      if (indiciesToDelete.length > 0) {
        patches.push({
          type: 'unset',
          path: [JSON.stringify(indiciesToDelete)]
        });
      }
      // spansAfterPruning now contain the array of spans as it will look after that above patch
      // Now let's go through them and combine any consecutive spans with identical marks into single
      // spans.
      var groups = [];
      var group = null;
      spansAfterPruning.forEach(function (span, index) {
        if (span.getAttribute('_type').get() == 'textspan') {
          if (group && (0, _isEqual3.default)(group.marks, span.marks)) {
            group.spans.push(span);
            group.lastIndex = index;
            return;
          }
          if (group && group.spans.length > 1) {
            groups.push(group);
          }
          group = {
            marks: span.marks,
            firstIndex: index,
            lastIndex: index,
            spans: [span]
          };
          return;
        }
        if (group && group.spans.length > 1) {
          groups.push(group);
        }
        group = null;
      });
      // Now groups contain only consecutive spans with identical marks, we may replace them with merged
      // versions of the same content. As each of these mutations change the length of the array, we must do them in
      // reverse order from back to front so that our indicies stay valid as we mutate
      groups.reverse().forEach(function (grp) {
        var value = {
          _type: 'textspan',
          content: grp.spans.map(function (span) {
            return span.content;
          }).join('')
        };
        if (grp.marks.length > 0) {
          value.marks = grp.marks;
        }
        patches.push({
          type: 'insert',
          position: 'replace',
          path: ['[' + grp.firstIndex + ':' + grp.lastIndex + ']'],
          value: [value]
        });
      });
      return patches;
    }
  }], [{
    key: 'createFromSlateParagraph',
    value: function createFromSlateParagraph(paragraph) {
      var spans = (0, _flatten3.default)(paragraph.nodes.toArray().map(function (childNode) {
        if (childNode.kind === 'text') {
          return (0, _docUtils.splitTextNodeIntoArraysOfCharacterBySpan)(childNode).map(function (textNode) {
            return TextSpanAccessor.createFromTextNode(childNode.key, textNode);
          });
        }
        return new NodeAccessor(childNode);
      }));
      if (spans.length == 0) {
        // There is always at least one span, albeit an empty one
        return new SpansAccessor([new TextSpanAccessor({
          key: (0, _randomKey2.default)(12),
          content: '',
          marks: []
        })]);
      }
      return new SpansAccessor(spans);
    }
  }]);

  function SpansAccessor(spans) {
    _classCallCheck(this, SpansAccessor);

    this.spans = spans;
  }

  _createClass(SpansAccessor, [{
    key: 'containerType',
    value: function containerType() {
      return 'array';
    }
  }, {
    key: 'length',
    value: function length() {
      return this.spans.length;
    }
  }, {
    key: 'setIndexAccessor',
    value: function setIndexAccessor(index, accessor) {
      var nextSpans = this.spans.slice();
      nextSpans[index] = accessor;
      return new SpansAccessor(nextSpans);
    }
  }, {
    key: 'setIndex',
    value: function setIndex(index, value) {
      throw new Error('setIndex w/o wrapping in accessor not supported for SpansAccessor yet.');
    }
  }, {
    key: 'getIndex',
    value: function getIndex(index) {
      return this.spans[index];
    }
  }, {
    key: 'insertItemsAt',
    value: function insertItemsAt(pos, items) {
      var itemAccessors = items.map(function (item) {
        // TODO: Standard way of creating appropriate containers on any item
        if (item._type == 'textspan') {
          return new TextSpanAccessor(item);
        }
        throw new Error('Unsupported item type "' + item._type + '"');
      });

      var nextSpans = void 0;
      if (this.spans.length == 0 && pos == 0) {
        nextSpans = itemAccessors;
      } else {
        nextSpans = this.spans.slice(0, pos).concat(itemAccessors).concat(this.spans.slice(pos));
      }
      return new SpansAccessor(nextSpans);
    }
  }, {
    key: 'get',
    value: function get() {
      // Convert internal intermediate format back to slate native format
      return (0, _docUtils.spanAccessorsToSlateNodes)(this.spans);
    }
  }]);

  return SpansAccessor;
}();

// Wraps a native slate paragraph representation, i.e. a Text node with spans


var ParagraphAccessor = exports.ParagraphAccessor = function () {
  function ParagraphAccessor(paragraph) {
    _classCallCheck(this, ParagraphAccessor);

    this.paragraph = paragraph;
  }

  _createClass(ParagraphAccessor, [{
    key: 'serialize',
    value: function serialize() {
      return {
        _type: 'paragraph',
        _key: this.paragraph.get('key'),
        nodes: this.getAttribute('nodes').serialize()
      };
    }
  }, {
    key: 'containerType',
    value: function containerType() {
      return 'object';
    }
  }, {
    key: 'getAttribute',
    value: function getAttribute(key) {
      if (key === '_key') {
        return new _mutator.ImmutableAccessor(this.paragraph.get('key'));
      }
      if (key === 'nodes') {
        return SpansAccessor.createFromSlateParagraph(this.paragraph);
      }
      throw new Error('Invalid attribute: ' + key);
    }
  }, {
    key: 'setAttribute',
    value: function setAttribute(key, value) {
      throw new Error('setAttribute not supported (yet, do we need it?)');
    }
  }, {
    key: 'setAttributeAccessor',
    value: function setAttributeAccessor(key, accessor) {
      if (key === 'nodes') {
        // convert SpansAccessor.spans to nodes array
        return new ParagraphAccessor(this.paragraph.setIn(['nodes'], accessor.get()));
      }
      throw new Error('Invalid attribute for ParagraphAccessor: ' + key);
    }
  }, {
    key: 'hasAttribute',
    value: function hasAttribute(key) {
      return key === 'nodes' || key === '_key';
    }
  }, {
    key: 'get',
    value: function get() {
      return this.paragraph;
    }
  }]);

  return ParagraphAccessor;
}();