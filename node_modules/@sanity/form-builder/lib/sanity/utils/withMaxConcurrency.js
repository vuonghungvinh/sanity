'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withMaxConcurrency = withMaxConcurrency;
exports.createThrottler = createThrottler;

var _multicast = require('@sanity/observable/multicast');

var _multicast2 = _interopRequireDefault(_multicast);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Takes a observable-returning function and returns a new function that limits on the number of
// concurrent observables.

/*:: import type {ObservableI, Subscription} from '../../typedefs/observable'*/


var DEFAULT_CONCURRENCY = 4;

function remove /*:: <T>*/(array /*: Array<T>*/, item /*: T*/) /*: Array<T>*/ {
  var index = array.indexOf(item);
  if (index > -1) {
    array.splice(index, 1);
  }
  return array;
}

function withMaxConcurrency(func /*: (any) => ObservableI<*>*/) {
  var concurrency /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CONCURRENCY;

  var throttler = createThrottler(concurrency);
  return function () {
    return _observable2.default.from(throttler(func.apply(undefined, arguments)));
  };
}

function createThrottler() {
  var concurrency /*: number*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONCURRENCY;

  var currentSubscriptions /*: Array<Subscription>*/ = [];
  var pendingObservables /*: Array<ObservableI<*>>*/ = [];
  var ready$ = new _multicast2.default();

  return request;

  function request(observable /*: ObservableI<*>*/) {
    return new _observable2.default(function (observer) {
      if (currentSubscriptions.length >= concurrency) {
        return scheduleAndWait(observable).mergeMap(request).subscribe(observer);
      }
      var subscription = observable.subscribe(observer);
      currentSubscriptions.push(subscription);
      return function () {
        remove(currentSubscriptions, subscription);
        remove(pendingObservables, observable);
        subscription.unsubscribe();
        check();
      };
    });
  }

  function scheduleAndWait(observable) {
    pendingObservables.push(observable);
    return ready$.asObservable().first(function (obs) {
      return obs === observable;
    });
  }

  function check() {
    while (pendingObservables.length > 0 && currentSubscriptions.length < concurrency) {
      ready$.next(pendingObservables.shift());
    }
  }
}