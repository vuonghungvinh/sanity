'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createPreviewObserver;

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _observableProps = require('observable-props');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var props = (0, _observableProps.configure)({ Observable: _observable2.default });

function resolveMissingHeads(value, paths) {
  return paths.filter(function (path) {
    return !(path[0] in value);
  });
}

function isReference(value) {
  return '_ref' in value;
}

function isDocument(value) {
  return '_id' in value;
}

function createEmpty(keys) {
  return keys.reduce(function (result, key) {
    result[key] = undefined;
    return result;
  }, {});
}

function createPreviewObserver(observeWithPaths) {

  function follow(value, paths) {
    if (!(0, _isArray3.default)(value) && !(0, _isObject3.default)(value)) {
      // Reached a leaf. Don't blow up
      return _observable2.default.of(value);
    }
    var missingHeads = resolveMissingHeads(value, paths);
    if (missingHeads.length > 0) {
      // Reached a node that is either a document (with _id), or a reference (with _ref) that
      // needs to be "materialized"

      var nextHeads = (0, _uniq3.default)(missingHeads.map(function (path) {
        return [path[0]];
      }));

      if (isReference(value) || isDocument(value)) {
        var id = isReference(value) ? value._ref : value._id;
        return observeWithPaths(id, nextHeads).switchMap(function (snapshot) {
          return follow(_extends({}, createEmpty(nextHeads), value, snapshot), paths);
        });
      }
    }

    var leads = {};
    paths.forEach(function (path) {
      var _path = _toArray(path),
          head = _path[0],
          tail = _path.slice(1);

      if (!leads[head]) {
        leads[head] = [];
      }
      leads[head].push(tail);
    });

    var next = Object.keys(leads).reduce(function (res, head) {
      var tails = leads[head];
      if (tails.every(function (tail) {
        return tail.length === 0;
      })) {
        res[head] = value[head];
      } else {
        res[head] = follow(value[head], tails);
      }
      return res;
    }, _extends({}, value));

    return props(_observable2.default.of(next), { wait: true });
  }

  return follow;
}