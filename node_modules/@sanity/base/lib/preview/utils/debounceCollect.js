'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debounceCollect;

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Takes a observable returning function and returns a debounced function that
// collects arguments until wait time has passed without receiving new calls.
// When wait period is over, calls the original function with the collected arguments

function debounceCollect(fn, wait) {
  var timer = void 0;
  var queue = {};
  var idx = 0;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new _observable2.default(function (obs) {
      clearTimeout(timer);
      timer = setTimeout(flush, wait);
      var queueItem = {
        args: args,
        observer: obs,
        completed: false
      };
      var id = idx++;
      queue[id] = queueItem;
      return function () {
        // console.log('completed', queueItem.args)
        queueItem.completed = true;
      };
    });
  };

  function flush() {
    var currentlyFlushingQueue = queue;
    queue = {};

    var queueItemIds = Object.keys(currentlyFlushingQueue)
    // Todo: use debug
    // .map(id => {
    //   if (currentlyFlushingQueue[id].completed) {
    //     console.log('Dropped', currentlyFlushingQueue[id].args)
    //   }
    //   return id
    // })
    .filter(function (id) {
      return !currentlyFlushingQueue[id].completed;
    });

    if (queueItemIds.length === 0) {
      // nothing to do
      return;
    }
    var collectedArgs = queueItemIds.map(function (id) {
      return currentlyFlushingQueue[id].args;
    });
    fn(collectedArgs).subscribe({
      next: function next(results) {
        results.forEach(function (result, i) {
          var queueItem = currentlyFlushingQueue[queueItemIds[i]];
          if (!queueItem.completed) {
            queueItem.observer.next(results[i]);
          }
        });
      },
      complete: function complete() {
        queueItemIds.forEach(function (id) {
          var entry = currentlyFlushingQueue[id];
          if (!entry.completed) {
            entry.observer.complete();
          }
        });
      },
      error: function error(err) {
        queueItemIds.forEach(function (id) {
          var entry = currentlyFlushingQueue[id];
          if (!entry.completed) {
            entry.observer.error(err);
          }
        });
      }
    });
  }
}