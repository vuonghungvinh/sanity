'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _multicast = require('@sanity/observable/multicast');

var _multicast2 = _interopRequireDefault(_multicast);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _resize = require('./resize');

var _resize2 = _interopRequireDefault(_resize);

var _scroll = require('./scroll');

var _scroll2 = _interopRequireDefault(_scroll);

var _orientationChange = require('./orientationChange');

var _orientationChange2 = _interopRequireDefault(_orientationChange);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ROOT_MARGIN_PX = 150;

/*
  Adapted from the polyfill at https://github.com/WICG/IntersectionObserver
*/
function isIntersectionObserverSupported() {
  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in IntersectionObserverEntry.prototype) {

    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/WICG/IntersectionObserver/issues/211
    if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {
      Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {
        get: function get() {
          return this.intersectionRatio > 0;
        }
      });
    }
    return true;
  }
  return false;
}

exports.default = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();


function createIntersectionObserverBased() {
  var intersectionObserverEntries$$ = new _multicast2.default();
  var intersectionObserver = new IntersectionObserver(callback, {
    threshold: 0,
    rootMargin: ROOT_MARGIN_PX + 'px'
  });

  function callback(entries) {
    entries.forEach(function (entry) {
      intersectionObserverEntries$$.next(entry);
    });
  }

  return function intersectionObservableFor(element) {
    return new _observable2.default(function (observer) {
      intersectionObserver.observe(element);
      observer.next();
      return function () {
        return intersectionObserver.unobserve(element);
      };
    }).mergeMap(function () {
      return intersectionObserverEntries$$.asObservable();
    }).filter(function (event) {
      return event.target === element;
    });
  };
}

// This can be removed when intersection observer are supported by the browsers we support
function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }

  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }

  function inViewport(element) {
    return function () {
      return intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
    };
  }

  return function intersectionObservableFor(element) {
    var isElementInViewport = inViewport(element);
    return _observable2.default.of(isElementInViewport()).merge(_resize2.default.merge(_scroll2.default)).merge(_orientationChange2.default).map(isElementInViewport)
    // todo: consider "faking" more of the IntersectionObserverEntry api if possible
    .map(function (isIntersecting) {
      return { isIntersecting: isIntersecting };
    });
  };
}