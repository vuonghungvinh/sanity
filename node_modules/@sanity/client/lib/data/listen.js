'use strict';

var assign = require('object-assign');
var Observable = require('@sanity/observable/minimal');
var encodeQueryString = require('./encodeQueryString');
var pick = require('../util/pick');
var defaults = require('../util/defaults');

var EventSource = typeof window !== 'undefined' && window.EventSource ? window.EventSource // Native browser EventSource
: require('@sanity/eventsource'); // Node.js, IE etc

var possibleOptions = ['includePreviousRevision', 'includeResult'];
var defaultOptions = {
  includeResult: true
};

module.exports = function listen(query, params) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var options = defaults(opts, defaultOptions);
  var listenOpts = pick(options, possibleOptions);
  var qs = encodeQueryString({ query: query, params: params, options: listenOpts });
  var _clientConfig = this.clientConfig,
      url = _clientConfig.url,
      token = _clientConfig.token,
      withCredentials = _clientConfig.withCredentials;


  var uri = '' + url + this.getDataUrl('listen', qs);
  var listenFor = options.events ? options.events : ['mutation'];
  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

  var esOptions = {};
  if (token || withCredentials) {
    esOptions.withCredentials = true;
  }

  if (token) {
    esOptions.headers = {
      Authorization: 'Bearer ' + token
    };
  }

  return new Observable(function (observer) {
    var es = new EventSource(uri, esOptions);

    es.addEventListener('error', onError, false);
    es.addEventListener('channelError', onChannelError, false);
    es.addEventListener('disconnect', onDisconnect, false);
    listenFor.forEach(function (type) {
      return es.addEventListener(type, onMessage, false);
    });

    function onError() {
      if (es.readyState === EventSource.CLOSED) {
        observer.complete();
      } else if (es.readyState === EventSource.CONNECTING) {
        emitReconnect();
      }
    }

    function onChannelError(err) {
      observer.error(cooerceError(err));
    }

    function onMessage(evt) {
      var event = parseEvent(evt);
      return event instanceof Error ? observer.error(event) : observer.next(event);
    }

    function onDisconnect(evt) {
      observer.complete();
      unsubscribe();
    }

    function unsubscribe() {
      listenFor.forEach(function (type) {
        return es.removeEventListener(type, onMessage, false);
      });
      es.removeEventListener('error', onError, false);
      es.removeEventListener('channelError', onChannelError, false);
      es.removeEventListener('disconnect', onDisconnect, false);
      es.close();
    }

    function emitReconnect() {
      if (shouldEmitReconnect) {
        observer.next({ type: 'reconnect' });
      }
    }

    return unsubscribe;
  });
};

function parseEvent(event) {
  try {
    var data = event.data && JSON.parse(event.data) || {};
    return assign({ type: event.type }, data);
  } catch (err) {
    return err;
  }
}

function cooerceError(err) {
  if (err instanceof Error) {
    return err;
  }

  var evt = parseEvent(err);
  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
}

function extractErrorMessage(err) {
  if (!err.error) {
    return err.message || 'Unknown listener error';
  }

  if (err.error.description) {
    return err.error.description;
  }

  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
}