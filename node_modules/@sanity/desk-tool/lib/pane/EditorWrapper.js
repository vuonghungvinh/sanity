'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _throttle2 = require('lodash/throttle');

var _throttle3 = _interopRequireDefault(_throttle2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
// Connects the FormBuilder with various sanity roles


var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _draftUtils = require('../utils/draftUtils');

var _formBuilder = require('part:@sanity/form-builder');

var _formBuilder2 = _interopRequireDefault(_formBuilder);

var _Editor = require('./Editor');

var _Editor2 = _interopRequireDefault(_Editor);

var _schema = require('part:@sanity/base/schema');

var _schema2 = _interopRequireDefault(_schema);

var _default = require('part:@sanity/components/buttons/default');

var _default2 = _interopRequireDefault(_default);

var _client = require('part:@sanity/base/client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var INITIAL_DOCUMENT_STATE = {
  isLoading: true,
  deletedSnapshot: null,
  snapshot: null
};

var INITIAL_STATE = {
  isSaving: true,
  isCreatingDraft: false,
  transactionResult: null,
  draft: INITIAL_DOCUMENT_STATE,
  published: INITIAL_DOCUMENT_STATE
};

function documentEventToState(event) {
  switch (event.type) {
    case 'rebase':
    case 'create':
    case 'createIfNotExists':
    case 'snapshot':
      {
        return {
          deletedSnapshot: null,
          snapshot: event.document
        };
      }
    case 'mutation':
      {
        return {
          deletedSnapshot: event.deletedSnapshot,
          snapshot: event.document ? _extends({}, event.document, {
            // todo: The following line is a temporary workaround for a problem with the mutator not
            // setting updatedAt on patches applied optimistic when they are received from server
            // can be removed when this is fixed
            _updatedAt: new Date().toISOString()
          }) : event.document
        };
      }
    default:
      {
        // eslint-disable-next-line no-console
        console.log('Unhandled document event type "%s"', event.type, event);
        return {};
      }
  }
}

function exists(draft, published) {
  return draft.snapshot || published.snapshot;
}

function isRecoverable(draft, published) {
  return !exists(draft, published) && (draft.deletedSnapshot || published.deletedSnapshot);
}

var EditorPane = function (_React$Component) {
  _inherits(EditorPane, _React$Component);

  function EditorPane() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, EditorPane);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = EditorPane.__proto__ || Object.getPrototypeOf(EditorPane)).call.apply(_ref, [this].concat(args))), _this), _this.state = INITIAL_STATE, _this.patchChannel = _formBuilder2.default.createPatchChannel(), _this.receiveDraftEvent = function (event) {
      if (event.type !== 'mutation') {
        return;
      }
      // Broadcast incoming patches to input components that applies patches on their own
      // Note: This is *experimental*
      _this.patchChannel.receivePatches({
        patches: event.patches,
        snapshot: event.document
      });
    }, _this.handleDiscardDraft = function () {
      _this.draft.delete();
      _this.draft.commit().subscribe(function () {
        // todo: error handling
      });
    }, _this.handleDelete = function () {
      var documentId = _this.props.documentId;

      var tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId)).delete((0, _draftUtils.getDraftId)(documentId));

      _observable2.default.from(tx.commit()).map(function (result) {
        return {
          type: 'success',
          result: result
        };
      }).catch(function (error) {
        return _observable2.default.of({
          type: 'error',
          message: 'An error occurred while attempting to delete document.\n        This usually means that you attempted to delete a document that other documents\n        refers to.',
          error: error
        });
      }).subscribe(function (result) {
        _this.setState({ transactionResult: result });
      });
    }, _this.handleClearTransactionResult = function () {
      _this.setState({ transactionResult: null });
    }, _this.handleUnpublish = function () {
      var documentId = _this.props.documentId;
      var published = _this.state.published;


      var tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId));

      if (published.snapshot) {
        tx = tx.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_createdAt', '_updatedAt'), {
          _id: (0, _draftUtils.getDraftId)(documentId)
        }));
      }

      _observable2.default.from(tx.commit()).map(function (result) {
        return {
          type: 'success',
          result: result
        };
      }).catch(function (error) {
        return _observable2.default.of({
          type: 'error',
          message: 'An error occurred while attempting to unpublish document.\n        This usually means that you attempted to {transactionResult.action} a document that other documents\n        refers to.',
          error: error
        });
      }).subscribe(function (result) {
        _this.setState({ transactionResult: result });
      });
    }, _this.handlePublish = function (draft) {

      _this.setState({ isPublishing: true });

      var publishedId = _this.getPublishedId();

      _this.published.createOrReplace(_extends({}, (0, _omit3.default)(draft, '_createdAt', '_updatedAt'), {
        _id: publishedId
      }));

      return _this.published.commit().mergeMap(function () {
        _this.draft.delete();
        return _this.draft.commit();
      }).subscribe(function () {
        return _this.setState({ isPublishing: false });
      });
    }, _this.handleChange = function (event) {
      var _this$state = _this.state,
          published = _this$state.published,
          draft = _this$state.draft;
      var typeName = _this.props.typeName;


      if (!draft.snapshot) {
        _this.draft.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_createdAt', '_updatedAt'), {
          _id: _this.getDraftId(),
          _type: typeName
        }));
      }

      _this.draft.patch(event.patches);
      _this.commit();
    }, _this.commit = (0, _throttle3.default)(function () {
      _this.setState({ isSaving: true });
      _this.draft.commit().subscribe({
        next: function next() {
          // todo
        },
        error: function error(_error) {
          // todo
        },
        complete: function complete() {
          _this.setState({ isSaving: false });
        }
      });
    }, 1000, { leading: true, trailing: true }), _this.handleRestoreDeleted = function () {
      var _this$state2 = _this.state,
          draft = _this$state2.draft,
          published = _this$state2.published;


      var commits = [];
      if (draft.deletedSnapshot) {
        _this.draft.createIfNotExists(draft.deletedSnapshot);
        commits.push(_this.draft.commit());
      } else if (published.deletedSnapshot) {
        _this.published.createIfNotExists(published.deletedSnapshot);
        commits.push(_this.published.commit());
      }
      commits.forEach(function (c) {
        c.subscribe({
          next: function next() {}
        });
      });
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(EditorPane, [{
    key: 'setup',
    value: function setup(documentId) {
      var _this2 = this;

      this.dispose();
      this.published = (0, _formBuilder.checkout)((0, _draftUtils.getPublishedId)(documentId));
      this.draft = (0, _formBuilder.checkout)((0, _draftUtils.getDraftId)(documentId));

      this.subscription = this.published.events.map(function (event) {
        return _extends({}, event, { version: 'published' });
      }).merge(this.draft.events.do(this.receiveDraftEvent).map(function (event) {
        return _extends({}, event, { version: 'draft' });
      })).subscribe(function (event) {
        _this2.setState(function (prevState) {
          var version = event.version; // either 'draft' or 'published'
          return _defineProperty({}, version, _extends({}, prevState[version] || {}, documentEventToState(event), {
            isLoading: false
          }));
        });
      });
    }
  }, {
    key: 'getDraftId',
    value: function getDraftId() {
      return (0, _draftUtils.getDraftId)(this.props.documentId);
    }
  }, {
    key: 'getPublishedId',
    value: function getPublishedId() {
      return (0, _draftUtils.getPublishedId)(this.props.documentId);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setup(this.props.documentId);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.documentId !== this.props.documentId) {
        this.setState(INITIAL_STATE);
        this.setup(nextProps.documentId);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.dispose();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      if (this.subscription) {
        this.subscription.unsubscribe();
        this.subscription = null;
      }
      this.published = null;
      this.draft = null;
    }
  }, {
    key: 'renderDeleted',
    value: function renderDeleted() {
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'h3',
          null,
          'This document just got deleted'
        ),
        _react2.default.createElement(
          'p',
          null,
          'You can undo deleting it until you close this window/tab'
        ),
        _react2.default.createElement(
          _default2.default,
          { onClick: this.handleRestoreDeleted },
          'Undo delete'
        )
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var typeName = this.props.typeName;
      var _state = this.state,
          draft = _state.draft,
          published = _state.published,
          isCreatingDraft = _state.isCreatingDraft,
          isUnpublishing = _state.isUnpublishing,
          transactionResult = _state.transactionResult,
          isPublishing = _state.isPublishing,
          isSaving = _state.isSaving;


      if (isRecoverable(draft, published)) {
        return this.renderDeleted();
      }

      return _react2.default.createElement(_Editor2.default, {
        patchChannel: this.patchChannel,
        type: _schema2.default.get(typeName),
        published: published.snapshot,
        draft: draft.snapshot,
        isLoading: draft.isLoading || published.isLoading,
        isSaving: isSaving,
        isPublishing: isPublishing,
        isUnpublishing: isUnpublishing,
        transactionResult: transactionResult,
        isCreatingDraft: isCreatingDraft,
        onDelete: this.handleDelete,
        onClearTransactionResult: this.handleClearTransactionResult,
        onDiscardDraft: this.handleDiscardDraft,
        onPublish: this.handlePublish,
        onUnpublish: this.handleUnpublish,
        onChange: this.handleChange
      });
    }
  }]);

  return EditorPane;
}(_react2.default.Component);

EditorPane.propTypes = {
  documentId: _propTypes2.default.string.isRequired,
  typeName: _propTypes2.default.string.isRequired
};
exports.default = EditorPane;