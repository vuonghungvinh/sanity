'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = route;

var _parseRoute = require('./parseRoute');

var _parseRoute2 = _interopRequireDefault(_parseRoute);

var _resolveStateFromPath = require('./resolveStateFromPath');

var _resolveStateFromPath2 = _interopRequireDefault(_resolveStateFromPath);

var _resolvePathFromState = require('./resolvePathFromState');

var _resolvePathFromState2 = _interopRequireDefault(_resolvePathFromState);

var _paramsEncoding = require('./utils/paramsEncoding');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/*:: import type {Transform, Router, RouteChildren} from './types'*/
/*:: type NodeOptions = {
  path?: string,
  children?: RouteChildren,
  transform?: {[key: string] : Transform<*>},
  scope?: string
}*/


function normalizeChildren(children /*: any*/) /*: RouteChildren*/ {
  if (Array.isArray(children) || typeof children === 'function') {
    return children;
  }
  return children ? [children] : [];
}

function isRoute(val /*: NodeOptions | Router | RouteChildren*/) {
  return val && '_isRoute' in val;
}

function normalizeArgs(path /*: string | NodeOptions*/, childrenOrOpts /*: NodeOptions | Router | RouteChildren*/, children /*: Router | RouteChildren*/) /*: NodeOptions*/ {
  if ((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object') {
    return path;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === 'function' || isRoute(childrenOrOpts)) {
    return { path: path, children: normalizeChildren(childrenOrOpts) };
  }
  if (children) {
    return _extends({ path: path }, childrenOrOpts, { children: normalizeChildren(children) });
  }
  return _extends({ path: path }, childrenOrOpts);
}

function route(routeOrOpts /*: string | NodeOptions*/, childrenOrOpts /*: NodeOptions | RouteChildren*/, children /*: Router | RouteChildren*/) /*: Router*/ {
  return createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children));
}

route.scope = function scope(scopeName /*: string*/) /*: Router*/ {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var options = normalizeArgs.apply(undefined, _toConsumableArray(rest));

  return createNode(_extends({}, options, {
    scope: scopeName
  }));
};

function normalize() {
  for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    paths[_key2] = arguments[_key2];
  }

  return paths.reduce(function (acc, path) {
    return acc.concat(path.split('/'));
  }, []).filter(Boolean);
}

route.intents = function intents(base) {
  var basePath = normalize(base).join('/');
  return route(basePath + '/:intent', [route(':params', {
    transform: {
      params: {
        toState: _paramsEncoding.decodeParams,
        toPath: _paramsEncoding.encodeParams
      }
    }
  })]);
};

var EMPTY_STATE = {};
function isRoot(pathname /*: string*/) /*: boolean*/ {
  var parts = pathname.split('/');
  for (var i = 0; i < parts.length; i++) {
    if (parts[i]) {
      return false;
    }
  }
  return true;
}

function createNode(options /*: NodeOptions*/) /*: Router*/ {
  var path = options.path,
      scope = options.scope,
      transform = options.transform,
      children = options.children;

  if (!path) {
    throw new TypeError('Missing path');
  }
  var parsedRoute = (0, _parseRoute2.default)(path);

  return {
    _isRoute: true, // todo: make a Router class instead
    scope: scope,
    route: parsedRoute,
    children: children || [],
    transform: transform,
    encode: function encode(state) {
      return (0, _resolvePathFromState2.default)(this, state);
    },
    decode: function decode(_path) {
      return (0, _resolveStateFromPath2.default)(this, _path);
    },

    isRoot: isRoot,
    isNotFound: function isNotFound(pathname /*: string*/) /*: boolean*/ {
      return this.decode(pathname) === null;
    },
    getBasePath: function getBasePath() /*: string*/ {
      return this.encode(EMPTY_STATE);
    },
    getRedirectBase: function getRedirectBase(pathname /*: string*/) /*: ?string*/ {
      if (isRoot(pathname)) {
        var basePath = this.getBasePath();
        // Check if basepath is something different than given
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}