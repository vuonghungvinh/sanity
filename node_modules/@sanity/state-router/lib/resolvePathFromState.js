'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

exports.default = resolvePathFromState;

var _findMatchingNodes = require('./findMatchingNodes');

var _findMatchingNodes2 = _interopRequireDefault(_findMatchingNodes);

var _debug = require('./utils/debug');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type {Node, MatchResult} from './types'*/
function resolvePathFromState(node /*: Node*/, state /*: Object*/) /*: string*/ {
  (0, _debug.debug)('Resolving path from state %o', state);

  var match /*: MatchResult*/ = (0, _findMatchingNodes2.default)(node, state);
  if (match.remaining.length > 0) {
    var remaining = match.remaining;
    throw new Error('Unable to find matching route for state. Could not map the following state key' + (remaining.length == 1 ? '' : 's') + ' to a valid url: ' + remaining.join(', '));
  }

  if (match.nodes.length === 0) {
    throw new Error('Unable to resolve path from given state: ' + JSON.stringify(state));
  }

  var scopedState = state;
  var relative = (0, _flatten3.default)(match.nodes.map(function (matchNode) {
    if (matchNode.scope) {
      scopedState = scopedState[matchNode.scope];
    }
    return matchNode.route.segments.map(function (segment) {
      if (segment.type === 'dir') {
        return segment.name;
      }
      var transform = matchNode.transform && matchNode.transform[segment.name];
      return transform ? transform.toPath(scopedState[segment.name]) : scopedState[segment.name];
    });
  })).join('/');

  (0, _debug.debug)('Resolved to /%s', relative);

  return '/' + relative;
}