'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePlugin = exports.resolveProjectRoot = undefined;

let resolveTreeAsync = (() => {
  var _ref = _asyncToGenerator(function* (options) {
    const projectManifest = yield (0, _readManifest2.default)(options);
    const plugins = yield (0, _resolvePlugins.resolvePlugins)(projectManifest.plugins || [], options);
    const withRoot = plugins.concat([getProjectRootPlugin(options.basePath, projectManifest)]);
    const flattened = withRoot.reduce(_flattenTree2.default, withRoot);
    const deduped = (0, _removeDuplicatePlugins2.default)(flattened);
    return deduped;
  });

  return function resolveTreeAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

exports.resolveParts = resolveParts;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _generateHelpUrl = require('@sanity/generate-help-url');

var _generateHelpUrl2 = _interopRequireDefault(_generateHelpUrl);

var _flattenTree = require('./flattenTree');

var _flattenTree2 = _interopRequireDefault(_flattenTree);

var _readManifest = require('./readManifest');

var _readManifest2 = _interopRequireDefault(_readManifest);

var _resolvePlugins = require('./resolvePlugins');

var _resolveProjectRoot = require('./resolveProjectRoot');

var _resolveProjectRoot2 = _interopRequireDefault(_resolveProjectRoot);

var _removeDuplicatePlugins = require('./removeDuplicatePlugins');

var _removeDuplicatePlugins2 = _interopRequireDefault(_removeDuplicatePlugins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = resolveTree;
const resolveProjectRoot = exports.resolveProjectRoot = _resolveProjectRoot2.default;
exports.resolvePlugin = _resolvePlugins.resolvePlugin;
function resolveParts(opts = {}) {
  const options = Object.assign({ basePath: process.cwd() }, opts);

  if (options.sync) {
    return mergeResult(resolveTree(options), options);
  }

  return resolveTree(options).then(plugins => mergeResult(plugins, options));
}

function resolveTreeSync(options) {
  const basePath = options.basePath || process.cwd();
  const manifest = (0, _readManifest2.default)(options);
  const plugins = (0, _resolvePlugins.resolvePlugins)(manifest.plugins || [], options).concat([getProjectRootPlugin(basePath, manifest)]);

  return plugins.reduce(_flattenTree2.default, plugins.slice());
}

function resolveTree(opts = {}) {
  const options = Object.assign({ basePath: process.cwd() }, opts);

  if (options.resolveProjectRoot) {
    // @todo Sync vs async
    const resolveOpts = Object.assign({}, options, { sync: true });
    options.basePath = (0, _resolveProjectRoot2.default)(resolveOpts);
  }

  return options.sync ? resolveTreeSync(options) : resolveTreeAsync(options);
}

function getProjectRootPlugin(basePath, manifest) {
  return {
    name: '(project root)',
    path: basePath,
    manifest: manifest,
    plugins: []
  };
}

function mergeResult(plugins, options = {}) {
  const definitions = {};
  const implementations = {};
  const result = { definitions, implementations, plugins

    // Find plugins that define parts, and do a basic validation on the syntax
  };const partPlugins = plugins.map(plugin => {
    if (!plugin.manifest.parts) {
      return false;
    }

    if (!Array.isArray(plugin.manifest.parts)) {
      const help = `See ${(0, _generateHelpUrl2.default)('plugin-parts-syntax')}`;
      throw new Error(`Plugin "${plugin.name}" has a "parts" property which is not an array\n${help}`);
    }

    return {
      parts: plugin.manifest.parts,
      plugin: plugin
    };
  }).filter(Boolean).reverse();

  partPlugins.forEach(({ parts, plugin }) => {
    parts.forEach(part => {
      if (part.name && part.path) {
        assignNonOverridablePart(plugin, part, implementations, definitions, options);
      } else if (part.name) {
        assignDefinitionForAbstractPart(plugin, part, definitions);
      }

      if (part.implements) {
        assignPartImplementation(plugin, part, implementations, definitions, options);
      }
    });
  });

  return result;
}

function assignNonOverridablePart(plugin, part, implementations, definitions, options) {
  // Actual, non-overridable part
  const prevDefinition = definitions[part.name];
  if (prevDefinition) {
    // Part already exists, non-overridable parts can't be redefined
    const existing = `"${prevDefinition.plugin}" (${prevDefinition.path})`;
    const current = `"${plugin.name}" (${plugin.path})`;
    throw new Error(`Plugins ${existing} and ${current} both define part "${part.name}"` + ' - did you mean to use "implements"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
  implementations[part.name] = [getImplementationDeclaration(plugin, part, options)];
}

function assignDefinitionForAbstractPart(plugin, part, definitions) {
  const prevDefinition = definitions[part.name];
  if (prevDefinition && !prevDefinition.loose) {
    // Part already exists, non-overridable parts can't be redefined
    const existing = `"${prevDefinition.plugin}" (${prevDefinition.path})`;
    const current = `"${plugin.name}" (${plugin.path})`;
    throw new Error(`Plugins ${existing} and ${current} both define part "${part.name}"` + ' - did you mean to use "implements"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  definitions[part.name] = getDefinitionDeclaration(plugin, part);
}

function assignPartImplementation(plugin, part, implementations, definitions, options) {
  const partName = part.implements;
  if (!part.path) {
    const current = `"${plugin.name}" (${plugin.path})`;
    throw new Error(`Plugin ${current} tries to implement a part "${partName}",` + ' but did not define a path. Did you mean to use "name"?\n' + 'See ' + (0, _generateHelpUrl2.default)('part-declare-vs-implement'));
  }

  const prevDefinition = definitions[partName];
  if (prevDefinition && !prevDefinition.isAbstract) {
    const existing = `"${prevDefinition.plugin}" (${prevDefinition.path})`;
    const current = `"${plugin.name}" (${plugin.path})`;
    throw new Error(`Plugin ${current} tried to implement part "${partName}", which is already declared` + ` as a non-overridable part by ${existing} - ` + 'See ' + (0, _generateHelpUrl2.default)('implement-non-overridable-part'));
  } else if (!prevDefinition) {
    // In some cases, a user might want to declare a new part name and
    // assign it a non-overridable implementation, while simulatenously
    // fulfilling an existing part using `implements`. In this case,
    // `name`, `implements` and `path` are all set, and we want the part
    // referenced in `implements` to be treated as a non-abstract part.
    // This is why we're explicitly setting `isAbstract` to true below
    // `loose` means that this declaration is "implicit" - the part isn't
    // defined as a `name` + `description` combination, so if we come across
    // a plugin that declares the part outright, we want to use that over this
    definitions[partName] = getDefinitionDeclaration(plugin, part, {
      isAbstract: true,
      loose: true
    });
  }

  if (!implementations[partName]) {
    implementations[partName] = [];
  }

  implementations[partName].push(getImplementationDeclaration(plugin, part, options));
}

function getDefinitionDeclaration(plugin, part, options = {}) {
  const isAbstract = typeof options.isAbstract === 'undefined' ? typeof part.path === 'undefined' : options.isAbstract;

  return {
    plugin: plugin.name,
    path: plugin.path,
    description: part.description,
    isAbstract: isAbstract,
    loose: options.loose
  };
}

function getImplementationDeclaration(plugin, part, options) {
  const paths = plugin.manifest.paths || {};
  const isLib = options.useCompiledPaths || plugin.path.split(_path2.default.sep).indexOf('node_modules') !== -1;
  const isDotPath = /^\.{1,2}[\\/]/.test(part.path);

  const basePath = isDotPath ? plugin.path : _path2.default.join(plugin.path, (isLib ? paths.compiled : paths.source) || '');

  const filePath = _path2.default.isAbsolute(part.path) ? part.path : _path2.default.resolve(_path2.default.join(basePath, part.path));

  return {
    plugin: plugin.name,
    path: filePath
  };
}