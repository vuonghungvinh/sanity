'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _startCase2 = require('lodash/startCase');

var _startCase3 = _interopRequireDefault(_startCase2);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dataAspects = require('config:@sanity/data-aspects');

var _dataAspects2 = _interopRequireDefault(_dataAspects);

var _generateHelpUrl = require('@sanity/generate-help-url');

var _generateHelpUrl2 = _interopRequireDefault(_generateHelpUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bundledTypeNames = ['geopoint', 'richDate', 'date', 'sanity.imageAsset', 'sanity.fileAsset'];

var BUNDLED_DOC_TYPES = ['sanity.imageAsset', 'sanity.fileAsset'];

function isDocumentType(type) {
  return type.type && type.type.name === 'document';
}

function isObjectType(type) {
  return type.type !== null && type.jsonType === 'object';
}

function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}

function schemaHasUserDefinedDocumentTypes(schema) {
  return schema.getTypeNames().some(function (typeName) {
    return !isBundledDocType(typeName) && isDocumentType(schema.get(typeName));
  });
}

var hasWarned = false;
function warnAboutHiddenTypes() {
  if (hasWarned) {
    return;
  }
  hasWarned = true;
  // eslint-disable-next-line no-console, prefer-template
  console.warn('ðŸ‘‹ Hi there! Looks like you have hidden types configured in your studio\'s config/@sanity/data-aspects.json' + (' This config is now obsolete and should be removed. Read more at ' + (0, _generateHelpUrl2.default)('toplevel-objects-to-document-type')));
}

var DataAspectsResolver = function () {
  function DataAspectsResolver(schema) {
    _classCallCheck(this, DataAspectsResolver);

    this.schema = schema;
    this.config = Object.assign({ hiddenTypes: [], typeOptions: {} }, _dataAspects2.default || {});
  }

  _createClass(DataAspectsResolver, [{
    key: 'getConfig',
    value: function getConfig() {
      return this.config;
    }
  }, {
    key: 'getField',
    value: function getField(type, fieldName) {
      return type.fields.filter(function (currField) {
        return currField.name === fieldName;
      });
    }
  }, {
    key: 'getType',
    value: function getType(typeName) {
      return this.schema.get(typeName);
    }
  }, {
    key: 'inferTypesLegacy',
    value: function inferTypesLegacy() {
      var _this = this;

      return (this.schema.getTypeNames() || []).filter(function (typeName) {
        // Exclude types which come bundled with Sanity
        return !bundledTypeNames.includes(typeName)
        // Exclude types which are explicitly named in (legacy) hiddenTypes config
        && !_this.config.hiddenTypes.includes(typeName)
        // Only include if its an object type
        && isObjectType(_this.getType(typeName));
      });
    }
  }, {
    key: 'getDocumentTypes',
    value: function getDocumentTypes() {
      var _this2 = this;

      if (this.config.hiddenTypes.length > 0) {
        warnAboutHiddenTypes();
      }
      return this.schema.getTypeNames().filter(function (typeName) {
        return !isBundledDocType(typeName) && isDocumentType(_this2.schema.get(typeName));
      });
    }
  }, {
    key: 'getInferredTypes',
    value: function getInferredTypes() {
      return schemaHasUserDefinedDocumentTypes(this.schema) ? this.getDocumentTypes(this.schema) : this.inferTypesLegacy();
    }
  }, {
    key: 'getDisplayName',
    value: function getDisplayName(typeName) {
      var typeOption = this.config.typeOptions[typeName] || {};
      var type = this.getType(typeName);
      return typeOption.displayName || type.title || (0, _startCase3.default)(typeName);
    }

    // TODO: limit and offset is not yet implemented i gradient and only works partly because of a fluke
    // fix this when gql support limit, offset and order

  }, {
    key: 'getListConstraints',
    value: function getListConstraints(typeName) {
      var typeOption = this.config.typeOptions[typeName];
      if (!typeOption) {
        return '';
      }
      var constraints = [];
      if (typeOption.order) {
        // prefix order items with . because that's what gql requires
        //constraints.push(typeOptions.order)
      }
      if (typeOption.limit || typeOption.limit == 0) {
        constraints.push('limit: ' + typeOption.limit);
      }
      if (typeOption.offset) {
        constraints.push('offset: ' + typeOption.offset);
      }
      return constraints.filter(Boolean).join(', ');
    }
  }, {
    key: 'getListQuery',
    value: function getListQuery(options) {
      var typeName = options.typeName,
          keyForId = options.keyForId,
          keyForDisplayFieldName = options.keyForDisplayFieldName;

      var fieldName = this.getItemDisplayField(typeName);
      var constraints = this.getListConstraints(typeName);
      var selection = '"' + keyForId + '": _id, "' + keyForDisplayFieldName + '": ' + fieldName;
      return this.schema.name + '.' + typeName + ' [' + constraints + '] {' + selection + '}';
    }
  }]);

  return DataAspectsResolver;
}();

exports.default = DataAspectsResolver;